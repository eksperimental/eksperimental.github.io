    <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <title>Kernel.SpecialForms â€“ Elixir v1.0.1</title>
      
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.9.1-dev">
    <link href="http://fonts.googleapis.com/css?family=Lato:400,300,700,900|Merriweather:300italic,300,700,700italic|Inconsolata:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="dist/app.css" />
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body>

    
    <div class="main">
<button class="sidebar-toggle">
  <i class="fa fa-bars"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="fa fa-bars"></i>
  </button>

  
    <div class="sidebar-projectDetails sidebar-projectLink">
      <h1 class="sidebar-projectName">
        Elixir
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.0.1
      </h2>
    </div>
    
      <img src="assets/logo.png" alt="Elixir" class="sidebar-projectImage">
    
  

  <div class="sidebar-search">
    <i class="fa fa-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" results="0" />
  </div>

  <ul class="sidebar-mainNav">
    
      <li><a href="README.html">README</a></li>
    

    <li><a href="overview.html">Overview</a></li>
  </ul>

  <ul class="sidebar-listNav">
    
      <li><a id="modules_list" href="#full_list">Modules</a></li>
    

    
      <li><a id="exceptions_list" href="#full_list">Exceptions</a></li>
    

    
      <li><a id="protocols_list" href="#full_list">Protocols</a></li>
    
  </ul>

  <ul id="full_list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section id="content" class="content">
  <div class="content-inner">


      <h1>
        Kernel.SpecialForms
        
        
      </h1>

      
        <section id="moduledoc" class="docstring">
          <p>In this module we define Elixir special forms. Special forms
cannot be overridden by the developer and are the basic
building blocks of Elixir code.</p>

<p>Some of those forms are lexical (like <code>alias</code>, <code>case</code>, etc).
The macros <code>{}</code> and <code>&lt;&lt;&gt;&gt;</code> are also special forms used to define
tuple and binary data structures respectively.</p>

<p>This module also documents Elixir&#39;s pseudo variables (<code>__ENV__</code>,
<code>__MODULE__</code>, <code>__DIR__</code> and <code>__CALLER__</code>). Pseudo variables return
information about Elixir&#39;s compilation environment and can only
be read, never assigned to.</p>

<p>Finally, it also documents 2 special forms, <code>__block__</code> and
<code>__aliases__</code>, which are not intended to be called directly by the
developer but they appear in quoted contents since they are essential
in Elixir&#39;s constructs.</p>

        </section>
      

      
        <section id="summary_details" class="details-list">
          <h1 id="summary" class="section-heading">Summary</h1>
          

          

          
  <div class="summary-macros summary">
    <h2>
      <a href="#macros_details">Macros</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#__CALLER__/0">__CALLER__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current calling environment as a <code>Macro.Env</code> struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__DIR__/0">__DIR__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current directory as a binary</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__ENV__/0">__ENV__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current environment information as a <code>Macro.Env</code> struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__MODULE__/0">__MODULE__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current module name as an atom or <code>nil</code> otherwise</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#^/1">^var</a>
  </div>
  
    <div class="summary-synopsis"><p>Accesses an already bound variable in match clauses. Also known as the pin operator</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#super/1">super(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Calls the overriden function when overriding it with <a href="Kernel.html#defoverridable/1"><code>Kernel.defoverridable/1</code></a></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&amp;/1">&amp;expr</a>
  </div>
  
    <div class="summary-synopsis"><p>Captures or creates an anonymous function</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive/1">receive(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks if there is a message matching the given clauses
in the current process mailbox</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#for/1">for(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#%{}/1">%{}</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates a map</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#{}/1">{args}</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates a tuple</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&lt;&lt;&gt;&gt;/1">&lt;&lt;args&gt;&gt;</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a new bitstring</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fn/1">fn
  [clauses]
end</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines an anonymous function</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#cond/1">cond(clauses)</a>
  </div>
  
    <div class="summary-synopsis"><p>Evaluates the expression corresponding to the first clause that
evaluates to a truthy value</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try/1">try(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Evaluates the given expressions and handle any error, exit
or throw that may have happened</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__block__/1">__block__(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Internal special form for block expressions</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__aliases__/1">__aliases__(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Internal special form to hold aliases information</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#unquote/1">unquote(expr)</a>
  </div>
  
    <div class="summary-synopsis"><p>Unquotes the given expression from inside a macro</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#unquote_splicing/1">unquote_splicing(expr)</a>
  </div>
  
    <div class="summary-synopsis"><p>Unquotes the given list expanding its arguments. Similar
to unquote</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#%/2">%</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates a struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#./2">left . right</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a remote call or an alias</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#quote/2">quote(opts, block)</a>
  </div>
  
    <div class="summary-synopsis"><p>Gets the representation of any expression</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#import/2">import(module, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p>Imports function and macros from other modules</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#case/2">case(condition, clauses)</a>
  </div>
  
    <div class="summary-synopsis"><p>Matches the given expression against the given clauses</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#=/2">left = right</a>
  </div>
  
    <div class="summary-synopsis"><p>Matches the value on the right against the pattern on the left</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#require/2">require(module, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p>Requires a given module to be compiled and loaded</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#::/2">left :: right</a>
  </div>
  
    <div class="summary-synopsis"><p>Used by types and bitstrings to specify types</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#alias/2">alias(module, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p><code>alias</code> is used to setup aliases, often useful with modules names</p>
</div>
  
</div>

  </div>


          

        </section>
      

      

      

      
        <section id="macros_details" class="details-list">
          <h1 class="section-heading">Macros</h1>
          <div class="detail">
  <div class="detail-header" id="%/2">
    <a href="#%/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">%</span>
      
  </div>
  
  <section class="docstring">
    <p>Creates a struct.</p>

<p>A struct is a tagged map that allows developers to provide
default values for keys, tags to be used in polymorphic
dispatches and compile time assertions.</p>

<p>To define a struct, you just need to implement the <code>__struct__/0</code>
function in a module:</p>

<pre><code class="elixir">defmodule User do
  def __struct__ do
    %{name: &quot;john&quot;, age: 27}
  end
end
</code></pre>

<p>In practice though, structs are usually defined with the
<a href="Kernel.html#defstruct/1"><code>Kernel.defstruct/1</code></a> macro:</p>

<pre><code class="elixir">defmodule User do
  defstruct name: &quot;john&quot;, age: 27
end
</code></pre>

<p>Now a struct can be created as follows:</p>

<pre><code class="elixir">%User{}
</code></pre>

<p>Underneath a struct is just a map with a <code>__struct__</code> field
pointing to the <code>User</code> module:</p>

<pre><code class="elixir">%User{} == %{__struct__: User, name: &quot;john&quot;, age: 27}
</code></pre>

<p>A struct also validates that the given keys are part of the defined
struct. The example below will fail because there is no key
<code>:full_name</code> in the <code>User</code> struct:</p>

<pre><code class="elixir">%User{full_name: &quot;john doe&quot;}
</code></pre>

<p>Note that a struct specifies a minimum set of keys required
for operations. Other keys can be added to structs via the
regular map operations:</p>

<pre><code class="elixir">user = %User{}
Map.put(user, :a_non_struct_key, :value)
</code></pre>

<p>An update operation specific for structs is also available:</p>

<pre><code class="elixir">%User{user | age: 28}
</code></pre>

<p>The syntax above will guarantee the given keys are valid at
compilation time and it will guarantee at runtime the given
argument is a struct, failing with <code>BadStructError</code> otherwise.</p>

<p>Although structs are maps, by default structs do not implement
any of the protocols implemented for maps. Check
<a href="Kernel.html#defprotocol/2"><code>Kernel.defprotocol/2</code></a> for more information on how structs
can be used with protocols for polymorphic dispatch. Also
see <a href="Kernel.html#struct/2"><code>Kernel.struct/2</code></a> for examples on how to create and update
structs dynamically.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="%{}/1">
    <a href="#%{}/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">%{}</span>
      
  </div>
  
  <section class="docstring">
    <p>Creates a map.</p>

<p>Maps are key-value stores where keys are compared
using the match operator (<code>===</code>). Maps can be created with
the <code>%{}</code> special form where keys are associated via <code>=&gt;</code>:</p>

<pre><code class="elixir">%{1 =&gt; 2}
</code></pre>

<p>Maps also support the keyword notation, as other special forms,
as long as they are at the end of the argument list:</p>

<pre><code class="elixir">%{hello: :world, with: :keywords}
%{:hello =&gt; :world, with: :keywords}
</code></pre>

<p>If a map has duplicated keys, the last key will always have
higher precedence:</p>

<pre><code class="iex elixir">iex&gt; %{a: :b, a: :c}
%{a: :c}
</code></pre>

<p>Conveniences for manipulating maps can be found in the
<code>Map</code> module.</p>

<h2>Access syntax</h2>

<p>Besides the access functions available in the <code>Map</code> module,
like <code>Map.get/3</code> and <code>Map.fetch/2</code>, a map can be accessed using the
<code>.</code> operator:</p>

<pre><code class="iex elixir">iex&gt; map = %{a: :b}
iex&gt; map.a
:b
</code></pre>

<p>Note that the <code>.</code> operator expects the field to exist in the map.
If not, an <code>ArgumentError</code> is raised.</p>

<h2>Update syntax</h2>

<p>Maps also support an update syntax:</p>

<pre><code class="iex elixir">iex&gt; map = %{:a =&gt; :b}
iex&gt; %{map | :a =&gt; :c}
%{:a =&gt; :c}
</code></pre>

<p>Notice the update syntax requires the given keys to exist.
Trying to update a key that does not exist will raise an <code>ArgumentError</code>.</p>

<h2>AST representation</h2>

<p>Regardless if <code>=&gt;</code> or the keywords syntax is used, Maps are
always represented internally as a list of two-items tuples
for simplicity:</p>

<pre><code class="iex elixir">iex&gt; quote do: %{:a =&gt; :b, c: :d}
{:%{}, [], [{:a, :b}, {:c, :d}]}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&amp;/1">
    <a href="#&amp;/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">&amp;expr</span>
      
  </div>
  
  <section class="docstring">
    <p>Captures or creates an anonymous function.</p>

<h2>Capture</h2>

<p>The capture operator is most commonly used to capture a
function with given name and arity from a module:</p>

<pre><code class="iex elixir">iex&gt; fun = &amp;Kernel.is_atom/1
iex&gt; fun.(:atom)
true
iex&gt; fun.(&quot;string&quot;)
false
</code></pre>

<p>In the example above, we captured <a href="Kernel.html#is_atom/1"><code>Kernel.is_atom/1</code></a> as an
anonymous function and then invoked it.</p>

<p>The capture operator can also be used to capture local functions,
including private ones, and imported functions by omitting the
module name:</p>

<pre><code class="elixir">&amp;local_function/1
</code></pre>

<h2>Anonymous functions</h2>

<p>The capture operator can also be used to partially apply
functions, where <code>&amp;1</code>, <code>&amp;2</code> and so on can be used as value
placeholders. For example:</p>

<pre><code class="iex elixir">iex&gt; double = &amp;(&amp;1 * 2)
iex&gt; double.(2)
4
</code></pre>

<p>In other words, <code>&amp;(&amp;1 * 2)</code> is equivalent to <code>fn x -&gt; x * 2 end</code>.
Another example using a local function:</p>

<pre><code class="iex elixir">iex&gt; fun = &amp;is_atom(&amp;1)
iex&gt; fun.(:atom)
true
</code></pre>

<p>The <code>&amp;</code> operator can be used with more complex expressions:</p>

<pre><code class="iex elixir">iex&gt; fun = &amp;(&amp;1 + &amp;2 + &amp;3)
iex&gt; fun.(1, 2, 3)
6
</code></pre>

<p>As well as with lists and tuples:</p>

<pre><code class="iex elixir">iex&gt; fun = &amp;{&amp;1, &amp;2}
iex&gt; fun.(1, 2)
{1, 2}

iex&gt; fun = &amp;[&amp;1|&amp;2]
iex&gt; fun.(1, 2)
[1|2]
</code></pre>

<p>The only restrictions when creating anonymous functions is that at
least one placeholder must be present, i.e. it must contain at least
<code>&amp;1</code>:</p>

<pre><code class="elixir"># No placeholder fails to compile
&amp;var

# Block expressions are also not supported
&amp;(foo(&amp;1, &amp;2); &amp;3 + &amp;4)
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="./2">
    <a href="#./2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left . right</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a remote call or an alias.</p>

<p>The dot (<code>.</code>) in Elixir can be used for remote calls:</p>

<pre><code class="iex elixir">iex&gt; String.downcase(&quot;FOO&quot;)
&quot;foo&quot;
</code></pre>

<p>In this example above, we have used <code>.</code> to invoke <code>downcase</code> in the
<a href="String.html"><code>String</code></a> alias, passing &quot;FOO&quot; as argument. We can also use the dot
for creating aliases:</p>

<pre><code class="iex elixir">iex&gt; Hello.World
Hello.World
</code></pre>

<p>This time, we have joined two aliases, defining the final alias
<code>Hello.World</code>.</p>

<h2>Syntax</h2>

<p>The right side of <code>.</code> may be a word starting in upcase, which represents
an alias, a word starting with lowercase or underscore, any valid language
operator or any name wrapped in single- or double-quotes. Those are all valid
examples:</p>

<pre><code class="iex elixir">iex&gt; Kernel.Sample
Kernel.Sample

iex&gt; Kernel.length([1, 2, 3])
3

iex&gt; Kernel.+(1, 2)
3

iex&gt; Kernel.&quot;length&quot;([1, 2, 3])
3

iex&gt; Kernel.&#39;+&#39;(1, 2)
3
</code></pre>

<p>Note that <code>Kernel.&quot;HELLO&quot;</code> will be treated as a remote call and not an alias.
This choice was done so every time single- or double-quotes are used, we have
a remote call regardless of the quote contents. This decision is also reflected
in the quoted expressions discussed below.</p>

<h2>Quoted expression</h2>

<p>When <code>.</code> is used, the quoted expression may take two distinct
forms. When the right side starts with a lowercase letter (or
underscore):</p>

<pre><code class="iex elixir">iex&gt; quote do: String.downcase(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}
</code></pre>

<p>Notice we have an inner tuple, containing the atom <code>:.</code> representing
the dot as first element:</p>

<pre><code class="elixir">{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}
</code></pre>

<p>This tuple follows the general quoted expression structure in Elixir,
with the name as first argument, some keyword list as metadata as second,
and the number of arguments as third. In this case, the arguments is the
alias <a href="String.html"><code>String</code></a> and the atom <code>:downcase</code>. The second argument is <strong>always</strong>
an atom:</p>

<pre><code class="iex elixir">iex&gt; quote do: String.&quot;downcase&quot;(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}
</code></pre>

<p>The tuple containing <code>:.</code> is wrapped in another tuple, which actually
represents the function call, and has <code>&quot;FOO&quot;</code> as argument.</p>

<p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p>

<pre><code class="iex elixir">iex&gt; quote do: Hello.World
{:__aliases__, [alias: false], [:Hello, :World]}
</code></pre>

<p>We got into more details about aliases in the <code>__aliases__</code> special form
documentation.</p>

<h2>Unquoting</h2>

<p>We can also use unquote to generate a remote call in a quoted expression:</p>

<pre><code class="iex elixir">iex&gt; x = :downcase
iex&gt; quote do: String.unquote(x)(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}
</code></pre>

<p>Similar to <code>Kernel.&quot;HELLO&quot;</code>, <code>unquote(x)</code> will always generate a remote call,
independent of the value of <code>x</code>. To generate an alias via the quoted expression,
one needs to rely on <code>Module.concat/2</code>:</p>

<pre><code class="iex elixir">iex&gt; x = Sample
iex&gt; quote do: Module.concat(String, unquote(x))
{{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],
 [{:__aliases__, [alias: false], [:String]}, Sample]}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="::/2">
    <a href="#::/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left :: right</span>
      
  </div>
  
  <section class="docstring">
    <p>Used by types and bitstrings to specify types.</p>

<p>This operator is used in two distinct occasions in Elixir.
It is used in typespecs to specify the type of a variable,
function or of a type itself:</p>

<pre><code class="elixir">@type number :: integer | float
@spec add(number, number) :: number
</code></pre>

<p>It may also be used in bit strings to specify the type
of a given bit segment:</p>

<pre><code class="elixir">&lt;&lt;int::integer-little, rest::bits&gt;&gt; = bits
</code></pre>

<p>Read the documentation for <code>Kernel.Typespec</code> and
<a href="#%3C%3C%3E%3E/1"><code>&lt;&lt;&gt;&gt;/1</code></a> for more information on typespecs and
bitstrings respectively.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&lt;&lt;&gt;&gt;/1">
    <a href="#&lt;&lt;&gt;&gt;/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">&lt;&lt;args&gt;&gt;</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a new bitstring.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; &lt;&lt; 1, 2, 3 &gt;&gt;
&lt;&lt; 1, 2, 3 &gt;&gt;
</code></pre>

<h2>Types</h2>

<p>A bitstring is made of many segments and each segment has a
type. There are 9 types used in bitstrings:</p>

<ul>
<li><code>integer</code></li>
<li><code>float</code></li>
<li><code>bits</code> (alias for bitstring)</li>
<li><code>bitstring</code></li>
<li><code>binary</code></li>
<li><code>bytes</code> (alias for binary)</li>
<li><code>utf8</code></li>
<li><code>utf16</code></li>
<li><code>utf32</code></li>
</ul>

<p>When no type is specified, the default is <code>integer</code>:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;
</code></pre>

<p>Elixir also accepts by default the segment to be a literal
string or a literal char list, which are by expanded to integers:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;0, &quot;foo&quot;&gt;&gt;
&lt;&lt;0, 102, 111, 111&gt;&gt;
</code></pre>

<p>Variables or any other type need to be explicitly tagged:</p>

<pre><code class="iex elixir">iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest&gt;&gt;
** (ArgumentError) argument error
</code></pre>

<p>We can solve this by explicitly tagging it as a binary:</p>

<pre><code class="iex elixir">iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest :: binary&gt;&gt;
&quot;foo&quot;
</code></pre>

<p>The utf8, utf16, and utf32 types are for unicode codepoints. They
can also be applied to literal strings and char lists:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;&quot;foo&quot; :: utf16&gt;&gt;
&lt;&lt;0, 102, 0, 111, 0, 111&gt;&gt;
iex&gt; &lt;&lt;&quot;foo&quot; :: utf32&gt;&gt;
&lt;&lt;0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111&gt;&gt;
</code></pre>

<h2>Options</h2>

<p>Many options can be given by using <code>-</code> as separator. Order is
arbitrary, so the following are all equivalent:</p>

<pre><code class="elixir">&lt;&lt;102 :: integer-native, rest :: binary&gt;&gt;
&lt;&lt;102 :: native-integer, rest :: binary&gt;&gt;
&lt;&lt;102 :: unsigned-big-integer, rest :: binary&gt;&gt;
&lt;&lt;102 :: unsigned-big-integer-size(8), rest :: binary&gt;&gt;
&lt;&lt;102 :: unsigned-big-integer-8, rest :: binary&gt;&gt;
&lt;&lt;102 :: 8-integer-big-unsigned, rest :: binary&gt;&gt;
&lt;&lt;102, rest :: binary&gt;&gt;
</code></pre>

<h3>Unit and Size</h3>

<p>The length of the match is equal to the <code>unit</code> (a number of bits) times the
<code>size</code> (the number of repeated segnments of length <code>unit</code>).</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Default Unit</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>integer</code></td>
<td>1 bit</td>
</tr>
<tr>
<td><code>float</code></td>
<td>1 bit</td>
</tr>
<tr>
<td><code>binary</code></td>
<td>8 bits</td>
</tr>
</tbody>
</table>

<p>Sizes for types are a bit more nuanced. The default size for integers is 8.</p>

<p>For floats, it is 64. For floats, <code>size * unit</code> must result in 32 or 64,
corresponding to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>
binary32 and binary64, respectively.</p>

<p>For binaries, the default is the size of the binary. Only the last binary in a
match can use the default size. All others must have their size specified
explicitly, even if the match is unambiguous. For example:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;name::binary-size(5), &quot; the &quot;, species::binary&gt;&gt; = &lt;&lt;&quot;Frank the Walrus&quot;&gt;&gt;
&quot;Frank the Walrus&quot;
iex&gt; {name, species}
{&quot;Frank&quot;, &quot;Walrus&quot;}
</code></pre>

<p>Failing to specify the size for the non-last causes compilation to fail:</p>

<pre><code class="elixir">&lt;&lt;name::binary, &quot; the &quot;, species::binary&gt;&gt; = &lt;&lt;&quot;Frank the Walrus&quot;&gt;&gt;
** (CompileError): a binary field without size is only allowed at the end of a binary pattern
</code></pre>

<h4>Shortcut Syntax</h4>

<p>Size and unit can also be specified using a syntax shortcut
when passing integer values:</p>

<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; &lt;&lt; x :: 8 &gt;&gt; == &lt;&lt; x :: size(8) &gt;&gt;
true
iex&gt; &lt;&lt; x :: 8 * 4 &gt;&gt; == &lt;&lt; x :: size(8)-unit(4) &gt;&gt;
true
</code></pre>

<p>This syntax reflects the fact the effective size is given by
multiplying the size by the unit.</p>

<h3>Modifiers</h3>

<p>Some types have associated modifiers to clear up ambiguity in byte
representation.</p>

<table>
<thead>
<tr>
<th>Modifier</th>
<th>Relevant Type(s)</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>signed</code></td>
<td><code>integer</code></td>
</tr>
<tr>
<td><code>unsigned</code> (default)</td>
<td><code>integer</code></td>
</tr>
<tr>
<td><code>little</code></td>
<td><code>integer</code>, <code>utf16</code>, <code>utf32</code></td>
</tr>
<tr>
<td><code>big</code> (default)</td>
<td><code>integer</code>, <code>utf16</code>, <code>utf32</code></td>
</tr>
<tr>
<td><code>native</code></td>
<td><code>integer</code>, <code>utf16</code>, <code>utf32</code></td>
</tr>
</tbody>
</table>

<h3>Sign</h3>

<p>Integers can be <code>signed</code> or <code>unsigned</code>, defaulting to <code>unsigned</code>.</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;int::integer&gt;&gt; =  &lt;&lt;-100&gt;&gt;
&lt;&lt;156&gt;&gt;
iex&gt; int
156
iex&gt; &lt;&lt;int::integer-signed&gt;&gt; =  &lt;&lt;-100&gt;&gt;
&lt;&lt;156&gt;&gt;
iex&gt; int
-100
</code></pre>

<p><code>signed</code> and <code>unsigned</code> are only used for matching binaries (see below) and
are only used for integers.</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;-100 :: signed, _rest :: binary&gt;&gt; = &lt;&lt;-100, &quot;foo&quot;&gt;&gt;
&lt;&lt;156, 102, 111, 111&gt;&gt;
</code></pre>

<h3>Endianness</h3>

<p>Elixir has three options for endianness: <code>big</code>, <code>little</code>, and <code>native</code>.
The default is <code>big</code>:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;number::little-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;
&lt;&lt;0, 1&gt;&gt;
iex&gt; number
256
iex&gt; &lt;&lt;number::big-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;
&lt;&lt;0, 1&gt;&gt;
iex&gt; number
1
</code></pre>

<p><code>native</code> is determined by the VM at startup and will depend on the
host operating system.</p>

<h2>Binary/Bitstring Matching</h2>

<p>Binary matching is a powerful feature in Elixir that is useful for extracting
information from binaries as well as pattern matching.</p>

<p>Binary matching can be used by itself to extract information from binaries:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt;&quot;Hello, &quot;, place::binary&gt;&gt; = &quot;Hello, World&quot;
&quot;Hello, World&quot;
iex&gt; place
&quot;World&quot;
</code></pre>

<p>Or as a part of function definitions to pattern match:</p>

<pre><code class="elixir">defmodule ImageTyper
  @png_signature &lt;&lt;137::size(8), 80::size(8), 78::size(8), 71::size(8),
                13::size(8), 10::size(8), 26::size(8), 10::size(8)&gt;&gt;
  @jpg_signature &lt;&lt;255::size(8), 216::size(8)&gt;&gt;

  def type(&lt;&lt;@png_signature, rest::binary&gt;&gt;), do: :png
  def type(&lt;&lt;@jpg_signature, rest::binary&gt;&gt;), do: :jpg
  def type(_), do :unknown
end
</code></pre>

<h3>Performance &amp; Optimizations</h3>

<p>The Erlang compiler can provide a number of optimizations on binary creation
and matching. To see optimization output, set the <code>bin_opt_info</code> compiler
option:</p>

<pre><code class="elixir">ERL_COMPILER_OPTIONS=bin_opt_info mix compile
</code></pre>

<p>To learn more about specific optimizations and performance considerations,
check out
<a href="http://www.erlang.org/doc/efficiency_guide/binaryhandling.html">Erlang&#39;s Efficiency Guide on handling binaries</a>.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="=/2">
    <a href="#=/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left = right</span>
      
  </div>
  
  <section class="docstring">
    <p>Matches the value on the right against the pattern on the left.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="^/1">
    <a href="#^/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">^var</span>
      
  </div>
  
  <section class="docstring">
    <p>Accesses an already bound variable in match clauses. Also known as the pin operator.</p>

<h2>Examples</h2>

<p>Elixir allows variables to be rebound via static single assignment:</p>

<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; x = x + 1
iex&gt; x
2
</code></pre>

<p>However, in some situations, it is useful to match against an existing
value, instead of rebinding. This can be done with the <code>^</code> special form,
colloquially known as the pin operator:</p>

<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; ^x = List.first([1])
iex&gt; ^x = List.first([2])
** (MatchError) no match of right hand side value: 2
</code></pre>

<p>Note that <code>^x</code> always refers to the value of <code>x</code> prior to the match. The
following example will match:</p>

<pre><code class="iex elixir">iex&gt; x = 0
iex&gt; {x, ^x} = {1, 0}
iex&gt; x
1
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="__CALLER__/0">
    <a href="#__CALLER__/0" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">__CALLER__</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns the current calling environment as a <code>Macro.Env</code> struct.</p>

<p>In the environment you can access the filename, line numbers,
set up aliases, the function and others.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="__DIR__/0">
    <a href="#__DIR__/0" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">__DIR__</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns the current directory as a binary.</p>

<p>Although the directory can be accessed as <code>Path.dirname(__ENV__.file)</code>,
this macro is a convenient shortcut.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="__ENV__/0">
    <a href="#__ENV__/0" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">__ENV__</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns the current environment information as a <code>Macro.Env</code> struct.</p>

<p>In the environment you can access the current filename,
line numbers, set up aliases, the current function and others.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="__MODULE__/0">
    <a href="#__MODULE__/0" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">__MODULE__</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns the current module name as an atom or <code>nil</code> otherwise.</p>

<p>Although the module can be accessed in the <code>__ENV__</code>, this macro
is a convenient shortcut.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="__aliases__/1">
    <a href="#__aliases__/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">__aliases__(args)</span>
      
  </div>
  
  <section class="docstring">
    <p>Internal special form to hold aliases information.</p>

<p>It is usually compiled to an atom:</p>

<pre><code class="iex elixir">iex&gt; quote do: Foo.Bar
{:__aliases__, [alias: false], [:Foo, :Bar]}
</code></pre>

<p>Elixir represents <code>Foo.Bar</code> as <code>__aliases__</code> so calls can be
unambiguously identified by the operator <code>:.</code>. For example:</p>

<pre><code class="iex elixir">iex&gt; quote do: Foo.bar
{{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}
</code></pre>

<p>Whenever an expression iterator sees a <code>:.</code> as the tuple key,
it can be sure that it represents a call and the second argument
in the list is an atom.</p>

<p>On the other hand, aliases holds some properties:</p>

<ol>
<li><p>The head element of aliases can be any term that must expand to
 an atom at compilation time.</p></li>
<li><p>The tail elements of aliases are guaranteed to always be atoms.</p></li>
<li><p>When the head element of aliases is the atom <code>:Elixir</code>, no expansion happen.</p></li>
</ol>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="__block__/1">
    <a href="#__block__/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">__block__(args)</span>
      
  </div>
  
  <section class="docstring">
    <p>Internal special form for block expressions.</p>

<p>This is the special form used whenever we have a block
of expressions in Elixir. This special form is private
and should not be invoked directly:</p>

<pre><code class="iex elixir">iex&gt; quote do: (1; 2; 3)
{:__block__, [], [1, 2, 3]}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="alias/2">
    <a href="#alias/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">alias(module, opts)</span>
      
  </div>
  
  <section class="docstring">
    <p><code>alias</code> is used to setup aliases, often useful with modules names.</p>

<h2>Examples</h2>

<p><code>alias</code> can be used to setup an alias for any module:</p>

<pre><code class="elixir">defmodule Math do
  alias MyKeyword, as: Keyword
end
</code></pre>

<p>In the example above, we have set up <code>MyKeyword</code> to be aliased
as <code>Keyword</code>. So now, any reference to <code>Keyword</code> will be
automatically replaced by <code>MyKeyword</code>.</p>

<p>In case one wants to access the original <code>Keyword</code>, it can be done
by accessing <code>Elixir</code>:</p>

<pre><code class="elixir">Keyword.values   #=&gt; uses MyKeyword.values
Elixir.Keyword.values #=&gt; uses Keyword.values
</code></pre>

<p>Notice that calling <code>alias</code> without the <code>as:</code> option automatically
sets an alias based on the last part of the module. For example:</p>

<pre><code class="elixir">alias Foo.Bar.Baz
</code></pre>

<p>Is the same as:</p>

<pre><code class="elixir">alias Foo.Bar.Baz, as: Baz
</code></pre>

<h2>Lexical scope</h2>

<p><code>import</code>, <code>require</code> and <code>alias</code> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won&#39;t affect the overall scope.</p>

<h2>Warnings</h2>

<p>If you alias a module and you don&#39;t use the alias, Elixir is
going to issue a warning implying the alias is not being used.</p>

<p>In case the alias is generated automatically by a macro,
Elixir won&#39;t emit any warnings though, since the alias
was not explicitly defined.</p>

<p>Both warning behaviours could be changed by explicitly
setting the <code>:warn</code> option to <code>true</code> or <code>false</code>.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="case/2">
    <a href="#case/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">case(condition, clauses)</span>
      
  </div>
  
  <section class="docstring">
    <p>Matches the given expression against the given clauses.</p>

<h2>Examples</h2>

<pre><code class="elixir">case thing do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value -&gt;
    value
end
</code></pre>

<p>In the example above, we match <code>thing</code> against each clause &quot;head&quot;
and execute the clause &quot;body&quot; corresponding to the first clause
that matches. If no clause matches, an error is raised.</p>

<h2>Variables handling</h2>

<p>Notice that variables bound in a clause &quot;head&quot; do not leak to the
outer context:</p>

<pre><code class="elixir">case data do
  {:ok, value} -&gt; value
  :error -&gt; nil
end

value #=&gt; unbound variable value
</code></pre>

<p>However, variables explicitly bound in the clause &quot;body&quot; are
accessible from the outer context:</p>

<pre><code class="elixir">value = 7

case lucky? do
  false -&gt; value = 13
  true  -&gt; true
end

value #=&gt; 7 or 13
</code></pre>

<p>In the example above, value is going to be <code>7</code> or <code>13</code> depending on
the value of <code>lucky?</code>. In case <code>value</code> has no previous value before
case, clauses that do not explicitly bind a value have the variable
bound to <code>nil</code>.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="cond/1">
    <a href="#cond/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">cond(clauses)</span>
      
  </div>
  
  <section class="docstring">
    <p>Evaluates the expression corresponding to the first clause that
evaluates to a truthy value.</p>

<p>Raises an error if all conditions evaluate to <code>nil</code> or <code>false</code>.</p>

<h2>Examples</h2>

<pre><code class="elixir">cond do
  1 + 1 == 1 -&gt;
    &quot;This will never match&quot;
  2 * 2 != 4 -&gt;
    &quot;Nor this&quot;
  true -&gt;
    &quot;This will&quot;
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="fn/1">
    <a href="#fn/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">fn
  [clauses]
end</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines an anonymous function.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; add = fn a, b -&gt; a + b end
iex&gt; add.(1, 2)
3
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="for/1">
    <a href="#for/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">for(args)</span>
      
  </div>
  
  <section class="docstring">
    <p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring.</p>

<p>Let&#39;s start with an example:</p>

<pre><code class="iex elixir">iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]
</code></pre>

<p>A comprehension accepts many generators and filters. Enumerable
generators are defined using <code>&lt;-</code>:</p>

<pre><code class="elixir"># A list generator:
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]

# A comprehension with two generators
iex&gt; for x &lt;- [1, 2], y &lt;- [2, 3], do: x*y
[2, 3, 4, 6]
</code></pre>

<p>Filters can also be given:</p>

<pre><code class="elixir"># A comprehension with a generator and a filter
iex&gt; for n &lt;- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n
[2, 4, 6]
</code></pre>

<p>Note generators can also be used to filter as it removes any value
that doesn&#39;t match the left side of <code>&lt;-</code>:</p>

<pre><code class="iex elixir">iex&gt; for {:user, name} &lt;- [user: &quot;john&quot;, admin: &quot;john&quot;, user: &quot;meg&quot;] do
...&gt;   String.upcase(name)
...&gt; end
[&quot;JOHN&quot;, &quot;MEG&quot;]
</code></pre>

<p>Bitstring generators are also supported and are very useful when you
need to organize bitstring streams:</p>

<pre><code class="iex elixir">iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels &gt;&gt;, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
</code></pre>

<p>Variable assignments inside the comprehension, be it in generators,
filters or inside the block, are not reflected outside of the
comprehension.</p>

<h2>Into</h2>

<p>In the examples above, the result returned by the comprehension was
always a list. The returned result can be configured by passing an
<code>:into</code> option, that accepts any structure as long as it implements
the <code>Collectable</code> protocol.</p>

<p>For example, we can use bitstring generators with the <code>:into</code> option
to easily remove all spaces in a string:</p>

<pre><code class="iex elixir">iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?\s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;
</code></pre>

<p>The <code>IO</code> module provides streams, that are both <code>Enumerable</code> and
<code>Collectable</code>, here is an upcase echo server using comprehensions:</p>

<pre><code class="elixir">for line &lt;- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do
  String.upcase(line)
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="import/2">
    <a href="#import/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">import(module, opts)</span>
      
  </div>
  
  <section class="docstring">
    <p>Imports function and macros from other modules.</p>

<p><code>import</code> allows one to easily access functions or macros from
others modules without using the qualified name.</p>

<h2>Examples</h2>

<p>If you are using several functions from a given module, you can
import those functions and reference them as local functions,
for example:</p>

<pre><code class="iex elixir">iex&gt; import List
iex&gt; flatten([1, [2], 3])
[1, 2, 3]
</code></pre>

<h2>Selector</h2>

<p>By default, Elixir imports functions and macros from the given
module, except the ones starting with underscore (which are
usually callbacks):</p>

<pre><code class="elixir">import List
</code></pre>

<p>A developer can filter to import only macros or functions via
the only option:</p>

<pre><code class="elixir">import List, only: :functions
import List, only: :macros
</code></pre>

<p>Alternatively, Elixir allows a developer to pass pairs of
name/arities to <code>:only</code> or <code>:except</code> as a fine grained control
on what to import (or not):</p>

<pre><code class="elixir">import List, only: [flatten: 1]
import String, except: [split: 2]
</code></pre>

<p>Notice that calling <code>except</code> for a previously declared <code>import</code>
simply filters the previously imported elements. For example:</p>

<pre><code class="elixir">import List, only: [flatten: 1, keyfind: 4]
import List, except: [flatten: 1]
</code></pre>

<p>After the two import calls above, only <code>List.keyfind/4</code> will be
imported.</p>

<h2>Underscore functions</h2>

<p>By default functions starting with <code>_</code> are not imported. If you really want
to import a function starting with <code>_</code> you must explicitly include it in the
<code>:only</code> selector.</p>

<pre><code class="elixir">import File.Stream, only: [__build__: 3]
</code></pre>

<h2>Lexical scope</h2>

<p>It is important to notice that <code>import</code> is lexical. This means you
can import specific macros inside specific functions:</p>

<pre><code class="elixir">defmodule Math do
  def some_function do
    # 1) Disable &quot;if/2&quot; from Kernel
    import Kernel, except: [if: 2]

    # 2) Require the new &quot;if&quot; macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end
</code></pre>

<p>In the example above, we imported macros from <code>MyMacros</code>,
replacing the original <code>if/2</code> implementation by our own
within that specific function. All other functions in that
module will still be able to use the original one.</p>

<h2>Warnings</h2>

<p>If you import a module and you don&#39;t use any of the imported
functions or macros from this module, Elixir is going to issue
a warning implying the import is not being used.</p>

<p>In case the import is generated automatically by a macro,
Elixir won&#39;t emit any warnings though, since the import
was not explicitly defined.</p>

<p>Both warning behaviours could be changed by explicitly
setting the <code>:warn</code> option to <code>true</code> or <code>false</code>.</p>

<h2>Ambiguous function/macro names</h2>

<p>If two modules <code>A</code> and <code>B</code> are imported and they both contain
a <code>foo</code> function with an arity of <code>1</code>, an error is only emitted
if an ambiguous call to <code>foo/1</code> is actually made; that is, the
errors are emitted lazily, not eagerly.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="quote/2">
    <a href="#quote/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">quote(opts, block)</span>
      
  </div>
  
  <section class="docstring">
    <p>Gets the representation of any expression.</p>

<h2>Examples</h2>

<pre><code class="elixir">quote do: sum(1, 2, 3)
#=&gt; {:sum, [], [1, 2, 3]}
</code></pre>

<h2>Explanation</h2>

<p>Any Elixir code can be represented using Elixir data structures.
The building block of Elixir macros is a tuple with three elements,
for example:</p>

<pre><code class="elixir">{:sum, [], [1, 2, 3]}
</code></pre>

<p>The tuple above represents a function call to <code>sum</code> passing 1, 2 and
3 as arguments. The tuple elements are:</p>

<ul>
<li><p>The first element of the tuple is always an atom or
another tuple in the same representation.</p></li>
<li><p>The second element of the tuple represents metadata.</p></li>
<li><p>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, which is
usually a variable (or a local call).</p></li>
</ul>

<h2>Options</h2>

<ul>
<li><p><code>:unquote</code> - when <code>false</code>, disables unquoting. Useful when you have a quote
inside another quote and want to control what quote is able to unquote.</p></li>
<li><p><code>:location</code> - when set to <code>:keep</code>, keeps the current line and file from
quote. Read the Stacktrace information section below for more
information.</p></li>
<li><p><code>:context</code> - sets the resolution context.</p></li>
<li><p><code>:bind_quoted</code> - passes a binding to the macro. Whenever a binding is
given, <code>unquote</code> is automatically disabled.</p></li>
</ul>

<h2>Quote literals</h2>

<p>Besides the tuple described above, Elixir has a few literals that
when quoted return themselves. They are:</p>

<pre><code class="elixir">:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1, 2]       #=&gt; Lists
&quot;strings&quot;    #=&gt; Strings
{key, value} #=&gt; Tuples with two elements
</code></pre>

<h2>Quote and macros</h2>

<p><code>quote</code> is commonly used with macros for code generation. As an exercise,
let&#39;s define a macro that multiplies a number by itself (squared). Note
there is no reason to define such as a macro (and it would actually be
seen as a bad practice), but it is simple enough that it allows us to focus
on the important aspects of quotes and macros:</p>

<pre><code class="elixir">defmodule Math do
  defmacro squared(x) do
    quote do
      unquote(x) * unquote(x)
    end
  end
end
</code></pre>

<p>We can invoke it as:</p>

<pre><code class="elixir">import Math
IO.puts &quot;Got #{squared(5)}&quot;
</code></pre>

<p>At first, there is nothing in this example that actually reveals it is a
macro. But what is happening is that, at compilation time, <code>squared(5)</code>
becomes <code>5 * 5</code>. The argument <code>5</code> is duplicated in the produced code, we
can see this behaviour in practice though because our macro actually has
a bug:</p>

<pre><code class="elixir">import Math
my_number = fn -&gt;
  IO.puts &quot;Returning 5&quot;
  5
end
IO.puts &quot;Got #{squared(my_number.())}&quot;
</code></pre>

<p>The example above will print:</p>

<pre><code class="elixir">Returning 5
Returning 5
25
</code></pre>

<p>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is
because a macro receives an expression and not a value (which is what we
would expect in a regular function). This means that:</p>

<pre><code class="elixir">squared(my_number.())
</code></pre>

<p>Actually expands to:</p>

<pre><code class="elixir">my_number.() * my_number.()
</code></pre>

<p>Which invokes the function twice, explaining why we get the printed value
twice! In the majority of the cases, this is actually unexpected behaviour,
and that&#39;s why one of the first things you need to keep in mind when it
comes to macros is to <strong>not unquote the same value more than once</strong>.</p>

<p>Let&#39;s fix our macro:</p>

<pre><code class="elixir">defmodule Math do
  defmacro squared(x) do
    quote do
      x = unquote(x)
      x * x
    end
  end
end
</code></pre>

<p>Now invoking <code>square(my_number.())</code> as before will print the value just
once.</p>

<p>In fact, this pattern is so common that most of the times you will want
to use the <code>bind_quoted</code> option with <code>quote</code>:</p>

<pre><code class="elixir">defmodule Math do
  defmacro squared(x) do
    quote bind_quoted: [x: x] do
      x * x
    end
  end
end
</code></pre>

<p><code>:bind_quoted</code> will translate to the same code as the example above.
<code>:bind_quoted</code> can be used in many cases and is seen as good practice,
not only because it helps us from running into common mistakes but also
because it allows us to leverage other tools exposed by macros, such as
unquote fragments discussed in some sections below.</p>

<p>Before we finish this brief introduction, you will notice that, even though
we defined a variable <code>x</code> inside our quote:</p>

<pre><code class="elixir">quote do
  x = unquote(x)
  x * x
end
</code></pre>

<p>When we call:</p>

<pre><code class="elixir">import Math
squared(5)
x #=&gt; ** (RuntimeError) undefined function or variable: x
</code></pre>

<p>We can see that <code>x</code> did not leak to the user context. This happens
because Elixir macros are hygienic, a topic we will discuss at length
in the next sections as well.</p>

<h2>Hygiene in variables</h2>

<p>Consider the following example:</p>

<pre><code class="elixir">defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

require Hygiene

a = 10
Hygiene.no_interference
a #=&gt; 10
</code></pre>

<p>In the example above, <code>a</code> returns 10 even if the macro
is apparently setting it to 1 because variables defined
in the macro do not affect the context the macro is executed in.
If you want to set or get a variable in the caller&#39;s context, you
can do it with the help of the <code>var!</code> macro:</p>

<pre><code class="elixir">defmodule NoHygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

require NoHygiene

a = 10
NoHygiene.interference
a #=&gt; 1
</code></pre>

<p>Note that you cannot even access variables defined in the same
module unless you explicitly give it a context:</p>

<pre><code class="elixir">defmodule Hygiene do
  defmacro write do
    quote do
      a = 1
    end
  end

  defmacro read do
    quote do
      a
    end
  end
end

Hygiene.write
Hygiene.read
#=&gt; ** (RuntimeError) undefined function or variable: a
</code></pre>

<p>For such, you can explicitly pass the current module scope as
argument:</p>

<pre><code class="elixir">defmodule ContextHygiene do
  defmacro write do
    quote do
      var!(a, ContextHygiene) = 1
    end
  end

  defmacro read do
    quote do
      var!(a, ContextHygiene)
    end
  end
end

ContextHygiene.write
ContextHygiene.read
#=&gt; 1
</code></pre>

<h2>Hygiene in aliases</h2>

<p>Aliases inside quote are hygienic by default.
Consider the following example:</p>

<pre><code class="elixir">defmodule Hygiene do
  alias HashDict, as: D

  defmacro no_interference do
    quote do: D.new
  end
end

require Hygiene
Hygiene.no_interference #=&gt; #HashDict&lt;[]&gt;
</code></pre>

<p>Notice that, even though the alias <code>D</code> is not available
in the context the macro is expanded, the code above works
because <code>D</code> still expands to <code>HashDict</code>.</p>

<p>Similarly, even if we defined an alias with the same name
before invoking a macro, it won&#39;t affect the macro&#39;s result:</p>

<pre><code class="elixir">defmodule Hygiene do
  alias HashDict, as: D

  defmacro no_interference do
    quote do: D.new
  end
end

require Hygiene
alias SomethingElse, as: D
Hygiene.no_interference #=&gt; #HashDict&lt;[]&gt;
</code></pre>

<p>In some cases, you want to access an alias or a module defined
in the caller. For such, you can use the <code>alias!</code> macro:</p>

<pre><code class="elixir">defmodule Hygiene do
  # This will expand to Elixir.Nested.hello
  defmacro no_interference do
    quote do: Nested.hello
  end

  # This will expand to Nested.hello for
  # whatever is Nested in the caller
  defmacro interference do
    quote do: alias!(Nested).hello
  end
end

defmodule Parent do
  defmodule Nested do
    def hello, do: &quot;world&quot;
  end

  require Hygiene
  Hygiene.no_interference
  #=&gt; ** (UndefinedFunctionError) ...

  Hygiene.interference
  #=&gt; &quot;world&quot;
end
</code></pre>

<h2>Hygiene in imports</h2>

<p>Similar to aliases, imports in Elixir are hygienic. Consider the
following code:</p>

<pre><code class="elixir">defmodule Hygiene do
  defmacrop get_size do
    quote do
      size(&quot;hello&quot;)
    end
  end

  def return_size do
    import Kernel, except: [size: 1]
    get_size
  end
end

Hygiene.return_size #=&gt; 5
</code></pre>

<p>Notice how <code>return_size</code> returns 5 even though the <code>size/1</code>
function is not imported. In fact, even if <code>return_size</code> imported
a function from another module, it wouldn&#39;t affect the function
result:</p>

<pre><code class="elixir">def return_size do
  import Dict, only: [size: 1]
  get_size
end
</code></pre>

<p>Calling this new <code>return_size</code> will still return 5 as result.</p>

<p>Elixir is smart enough to delay the resolution to the latest
moment possible. So, if you call <code>size(&quot;hello&quot;)</code> inside quote,
but no <code>size/1</code> function is available, it is then expanded in
the caller:</p>

<pre><code class="elixir">defmodule Lazy do
  defmacrop get_size do
    import Kernel, except: [size: 1]

    quote do
      size([a: 1, b: 2])
    end
  end

  def return_size do
    import Kernel, except: [size: 1]
    import Dict, only: [size: 1]
    get_size
  end
end

Lazy.return_size #=&gt; 2
</code></pre>

<h2>Stacktrace information</h2>

<p>When defining functions via macros, developers have the option of
choosing if runtime errors will be reported from the caller or from
inside the quote. Let&#39;s see an example:</p>

<pre><code class="elixir"># adder.ex
defmodule Adder do
  @doc &quot;Defines a function that adds two numbers&quot;
  defmacro defadd do
    quote location: :keep do
      def add(a, b), do: a + b
    end
  end
end

# sample.ex
defmodule Sample do
  import Adder
  defadd
end
</code></pre>

<p>When using <code>location: :keep</code> and invalid arguments are given to
<code>Sample.add/2</code>, the stacktrace information will point to the file
and line inside the quote. Without <code>location: :keep</code>, the error is
reported to where <code>defadd</code> was invoked. Note <code>location: :keep</code> affects
only definitions inside the quote.</p>

<h2>Binding and unquote fragments</h2>

<p>Elixir quote/unquote mechanisms provides a functionality called
unquote fragments. Unquote fragments provide an easy way to generate
functions on the fly. Consider this example:</p>

<pre><code class="elixir">kv = [foo: 1, bar: 2]
Enum.each kv, fn {k, v} -&gt;
  def unquote(k)(), do: unquote(v)
end
</code></pre>

<p>In the example above, we have generated the functions <code>foo/0</code> and
<code>bar/0</code> dynamically. Now, imagine that, we want to convert this
functionality into a macro:</p>

<pre><code class="elixir">defmacro defkv(kv) do
  Enum.map kv, fn {k, v} -&gt;
    quote do
      def unquote(k)(), do: unquote(v)
    end
  end
end
</code></pre>

<p>We can invoke this macro as:</p>

<pre><code class="elixir">defkv [foo: 1, bar: 2]
</code></pre>

<p>However, we can&#39;t invoke it as follows:</p>

<pre><code class="elixir">kv = [foo: 1, bar: 2]
defkv kv
</code></pre>

<p>This is because the macro is expecting its arguments to be a
keyword list at <strong>compilation</strong> time. Since in the example above
we are passing the representation of the variable <code>kv</code>, our
code fails.</p>

<p>This is actually a common pitfall when developing macros. We are
assuming a particular shape in the macro. We can work around it
by unquoting the variable inside the quoted expression:</p>

<pre><code class="elixir">defmacro defkv(kv) do
  quote do
    Enum.each unquote(kv), fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end
</code></pre>

<p>If you try to run our new macro, you will notice it won&#39;t
even compile, complaining that the variables <code>k</code> and <code>v</code>
do not exist. This is because of the ambiguity: <code>unquote(k)</code>
can either be an unquote fragment, as previously, or a regular
unquote as in <code>unquote(kv)</code>.</p>

<p>One solution to this problem is to disable unquoting in the
macro, however, doing that would make it impossible to inject the
<code>kv</code> representation into the tree. That&#39;s when the <code>:bind_quoted</code>
option comes to the rescue (again!). By using <code>:bind_quoted</code>, we
can automatically disable unquoting while still injecting the
desired variables into the tree:</p>

<pre><code class="elixir">defmacro defkv(kv) do
  quote bind_quoted: [kv: kv] do
    Enum.each kv, fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end
</code></pre>

<p>In fact, the <code>:bind_quoted</code> option is recommended every time
one desires to inject a value into the quote.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="receive/1">
    <a href="#receive/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">receive(args)</span>
      
  </div>
  
  <section class="docstring">
    <p>Checks if there is a message matching the given clauses
in the current process mailbox.</p>

<p>In case there is no such message, the current process hangs
until a message arrives or waits until a given timeout value.</p>

<h2>Examples</h2>

<pre><code class="elixir">receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
end
</code></pre>

<p>An optional after clause can be given in case the message was not
received after the specified period of time:</p>

<pre><code class="elixir">receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
after
  5000 -&gt;
    IO.puts :stderr, &quot;No message in 5 seconds&quot;
end
</code></pre>

<p>The <code>after</code> clause can be specified even if there are no match clauses.
There are two special cases for the timeout value given to <code>after</code></p>

<ul>
<li><p><code>:infinity</code> - the process should wait indefinitely for a matching
message, this is the same as not using a timeout</p></li>
<li><p>0 - if there is no matching message in the mailbox, the timeout
will occur immediately</p></li>
</ul>

<h2>Variables handling</h2>

<p>The <code>receive</code> special form handles variables exactly as the <code>case</code>
special macro. For more information, check the docs for <a href="#case/2"><code>case/2</code></a>.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="require/2">
    <a href="#require/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">require(module, opts)</span>
      
  </div>
  
  <section class="docstring">
    <p>Requires a given module to be compiled and loaded.</p>

<h2>Examples</h2>

<p>Notice that usually modules should not be required before usage,
the only exception is if you want to use the macros from a module.
In such cases, you need to explicitly require them.</p>

<p>Let&#39;s suppose you created your own <code>if</code> implementation in the module
<code>MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code>MyMacros</code>:</p>

<pre><code class="elixir">defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end
</code></pre>

<p>An attempt to call a macro that was not loaded will raise an error.</p>

<h2>Alias shortcut</h2>

<p><code>require</code> also accepts <code>as:</code> as an option so it automatically sets
up an alias. Please check <code>alias</code> for more information.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="super/1">
    <a href="#super/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">super(args)</span>
      
  </div>
  
  <section class="docstring">
    <p>Calls the overriden function when overriding it with <a href="Kernel.html#defoverridable/1"><code>Kernel.defoverridable/1</code></a>.</p>

<p>See <a href="Kernel.html#defoverridable/1"><code>Kernel.defoverridable/1</code></a> for more information and documentation.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="try/1">
    <a href="#try/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">try(args)</span>
      
  </div>
  
  <section class="docstring">
    <p>Evaluates the given expressions and handle any error, exit
or throw that may have happened.</p>

<h2>Examples</h2>

<pre><code class="elixir">try do
  do_something_that_may_fail(some_arg)
rescue
  ArgumentError -&gt;
    IO.puts &quot;Invalid argument given&quot;
catch
  value -&gt;
    IO.puts &quot;caught #{value}&quot;
else
  value -&gt;
    IO.puts &quot;Success! The result was #{value}&quot;
after
  IO.puts &quot;This is printed regardless if it failed or succeed&quot;
end
</code></pre>

<p>The rescue clause is used to handle exceptions, while the catch
clause can be used to catch thrown values. The else clause can
be used to control flow based on the result of the expression.
Catch, rescue and else clauses work based on pattern matching.</p>

<p>Note that calls inside <code>try</code> are not tail recursive since the VM
needs to keep the stacktrace in case an exception happens.</p>

<h2>Rescue clauses</h2>

<p>Besides relying on pattern matching, rescue clauses provides some
conveniences around exceptions that allows one to rescue an
exception by its name. All the following formats are valid rescue
expressions:</p>

<pre><code class="elixir">try do
  UndefinedModule.undefined_function
rescue
  UndefinedFunctionError -&gt; nil
end

try do
  UndefinedModule.undefined_function
rescue
  [UndefinedFunctionError] -&gt; nil
end

# rescue and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x in [UndefinedFunctionError] -&gt; nil
end

# rescue all and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x -&gt; nil
end
</code></pre>

<h2>Erlang errors</h2>

<p>Erlang errors are transformed into Elixir ones during rescue:</p>

<pre><code class="elixir">try do
  :erlang.error(:badarg)
rescue
  ArgumentError -&gt; :ok
end
</code></pre>

<p>The most common Erlang errors will be transformed into their
Elixir counter-part. Those which are not will be transformed
into <code>ErlangError</code>:</p>

<pre><code class="elixir">try do
  :erlang.error(:unknown)
rescue
  ErlangError -&gt; :ok
end
</code></pre>

<p>In fact, ErlangError can be used to rescue any error that is
not an Elixir error proper. For example, it can be used to rescue
the earlier <code>:badarg</code> error too, prior to transformation:</p>

<pre><code class="elixir">try do
  :erlang.error(:badarg)
rescue
  ErlangError -&gt; :ok
end
</code></pre>

<h2>Catching throws and exits</h2>

<p>The catch clause can be used to catch throws values and exits.</p>

<pre><code class="elixir">try do
  exit(:shutdown)
catch
  :exit, :shutdown -&gt; IO.puts &quot;Exited with shutdown reason&quot;
end

try do
  throw(:sample)
catch
  :throw, :sample -&gt;
    IO.puts &quot;sample thrown&quot;
end
</code></pre>

<p>catch values also support <code>:error</code>, as in Erlang, although it is
commonly avoided in favor of raise/rescue control mechanisms.</p>

<h2>Else clauses</h2>

<p>Else clauses allow the result of the expression to be pattern
matched on:</p>

<pre><code class="elixir">x = 2
try do
  1 / x
rescue
  ArithmeticError -&gt;
    :infinity
else
  y when y &lt; 1 and y &gt; -1 -&gt;
    :small
  _ -&gt;
    :large
end
</code></pre>

<p>If an else clause is not present the result of the expression will
be return, if no exceptions are raised:</p>

<pre><code class="elixir">x = 1
^x =
  try do
    1 / x
  rescue
    ArithmeticError -&gt;
      :infinity
  end
</code></pre>

<p>However when an else clause is present but the result of the expression
does not match any of the patterns an exception will be raised. This
exception will not be caught by a catch or rescue in the same try:</p>

<pre><code class="elixir">x = 1
try do
  try do
    1 / x
  rescue
    # The TryClauseError can not be rescued here:
    TryClauseError -&gt;
      :error_a
  else
    0 -&gt;
      :small
  end
rescue
  # The TryClauseError is rescued here:
  TryClauseError -&gt;
    :error_b
end
</code></pre>

<p>Similarly an exception inside an else clause is not caught or rescued
inside the same try:</p>

<pre><code class="elixir">try do
  try do
    nil
  catch
    # The exit(1) call below can not be caught here:
    :exit, _ -&gt;
      :exit_a
  else
    _ -&gt;
      exit(1)
  end
catch
  # The exit is caught here:
  :exit, _ -&gt;
    :exit_b
end
</code></pre>

<p>This means the VM no longer needs to keep the stacktrace once inside
an else clause and so tail recursion is possible when using a <code>try</code>
with a tail call as the final call inside an else clause. The same
is <code>true</code> for <code>rescue</code> and <code>catch</code> clauses.</p>

<h2>Variable handling</h2>

<p>Since an expression inside <code>try</code> may not have been evaluated
due to an exception, any variable created inside <code>try</code> cannot
be accessed externally. For instance:</p>

<pre><code class="elixir">try do
  x = 1
  do_something_that_may_fail(same_arg)
  :ok
catch
  _, _ -&gt; :failed
end

x #=&gt; unbound variable &quot;x&quot;
</code></pre>

<p>In the example above, <code>x</code> cannot be accessed since it was defined
inside the <code>try</code> clause. A common practice to address this issue
is to return the variables defined inside <code>try</code>:</p>

<pre><code class="elixir">x =
  try do
    x = 1
    do_something_that_may_fail(same_arg)
    x
  catch
    _, _ -&gt; :failed
  end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="unquote/1">
    <a href="#unquote/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">unquote(expr)</span>
      
  </div>
  
  <section class="docstring">
    <p>Unquotes the given expression from inside a macro.</p>

<h2>Examples</h2>

<p>Imagine the situation you have a variable <code>value</code> and
you want to inject it inside some quote. The first attempt
would be:</p>

<pre><code class="elixir">value = 13
quote do: sum(1, value, 3)
</code></pre>

<p>Which would then return:</p>

<pre><code class="elixir">{:sum, [], [1, {:value, [], quoted}, 3]}
</code></pre>

<p>Which is not the expected result. For this, we use unquote:</p>

<pre><code class="elixir">value = 13
quote do: sum(1, unquote(value), 3)
#=&gt; {:sum, [], [1, 13, 3]}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="unquote_splicing/1">
    <a href="#unquote_splicing/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">unquote_splicing(expr)</span>
      
  </div>
  
  <section class="docstring">
    <p>Unquotes the given list expanding its arguments. Similar
to unquote.</p>

<h2>Examples</h2>

<pre><code class="elixir">values = [2, 3, 4]
quote do: sum(1, unquote_splicing(values), 5)
#=&gt; {:sum, [], [1, 2, 3, 4, 5]}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="{}/1">
    <a href="#{}/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">{args}</span>
      
  </div>
  
  <section class="docstring">
    <p>Creates a tuple.</p>

<p>Only two item tuples are considered literals in Elixir.
Therefore all other tuples are represented in the AST
as a call to the special form <code>:{}</code>.</p>

<p>Conveniences for manipulating tuples can be found in the
<code>Tuple</code> module. Some functions for working with tuples are
also available in <a href="Kernel.html"><code>Kernel</code></a>, namely <a href="Kernel.html#elem/2"><code>Kernel.elem/2</code></a>,
<a href="Kernel.html#put_elem/3"><code>Kernel.put_elem/3</code></a> and <a href="Kernel.html#tuple_size/1"><code>Kernel.tuple_size/1</code></a>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; {1, 2, 3}
{1, 2, 3}

iex&gt; quote do: {1, 2, 3}
{:{}, [], [1, 2, 3]}
</code></pre>

  </section>
</div>

        </section>
      

      
        <footer class="footer">
      <p>
        Designed by
        <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>
        and the
        <a href="https://github.com/elixir-lang/ex_doc/graphs/contributors" target="_blank">ExDoc team</a>.
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.9.1-dev).
      </p>
    </footer>
  </div>
</section>
</div>
    <script src="dist/app.js"></script>
  </body>
</html>

