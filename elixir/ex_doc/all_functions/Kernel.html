    <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <title>Kernel â€“ Elixir v1.0.1</title>
      
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.9.1-dev">
    <link href="http://fonts.googleapis.com/css?family=Lato:400,300,700,900|Merriweather:300italic,300,700,700italic|Inconsolata:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="dist/app.css" />
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body>

    
    <div class="main">
<button class="sidebar-toggle">
  <i class="fa fa-bars"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="fa fa-bars"></i>
  </button>

  
    <div class="sidebar-projectDetails sidebar-projectLink">
      <h1 class="sidebar-projectName">
        Elixir
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.0.1
      </h2>
    </div>
    
      <img src="assets/logo.png" alt="Elixir" class="sidebar-projectImage">
    
  

  <div class="sidebar-search">
    <i class="fa fa-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" results="0" />
  </div>

  <ul class="sidebar-mainNav">
    
      <li><a href="README.html">README</a></li>
    

    <li><a href="overview.html">Overview</a></li>
  </ul>

  <ul class="sidebar-listNav">
    
      <li><a id="modules_list" href="#full_list">Modules</a></li>
    

    
      <li><a id="exceptions_list" href="#full_list">Exceptions</a></li>
    

    
      <li><a id="protocols_list" href="#full_list">Protocols</a></li>
    
  </ul>

  <ul id="full_list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section id="content" class="content">
  <div class="content-inner">


      <h1>
        Kernel
        
        
      </h1>

      
        <section id="moduledoc" class="docstring">
          <p><a href="Kernel.html#content"><code>Kernel</code></a> provides the default macros and functions
Elixir imports into your environment. These macros and functions
can be skipped or cherry-picked via the <code>import</code> macro. For
instance, if you want to tell Elixir not to import the <code>if</code>
macro, you can do:</p>

<pre><code class="elixir">import Kernel, except: [if: 2]
</code></pre>

<p>Elixir also has special forms that are always imported and
cannot be skipped. These are described in <a href="Kernel.SpecialForms.html"><code>Kernel.SpecialForms</code></a>.</p>

<p>Some of the functions described in this module are inlined by
the Elixir compiler into their Erlang counterparts in the <code>:erlang</code>
module. Those functions are called BIFs (builtin internal functions)
in Erlang-land and they exhibit interesting properties, as some of
them are allowed in guards and others are used for compiler
optimizations.</p>

<p>Most of the inlined functions can be seen in effect when capturing
the function:</p>

<pre><code class="iex elixir">iex&gt; &amp;Kernel.is_atom/1
&amp;:erlang.is_atom/1
</code></pre>

<p>Those functions will be explicitly marked in their docs as
&quot;inlined by the compiler&quot;.</p>

        </section>
      

      
        <section id="summary_details" class="details-list">
          <h1 id="summary" class="section-heading">Summary</h1>
          

          
  <div class="summary-functions summary">
    <h2>
      <a href="#functions_details">Functions</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#make_ref/0">make_ref()</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns an almost unique reference</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#node/0">node()</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns an atom representing the name of the local node.
If the node is not alive, <code>:nonode@nohost</code> is returned instead</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#self/0">self()</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the pid (process identifier) of the calling process</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#throw/1">throw(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>A non-local return from a function. Check <a href="Kernel.SpecialForms.html#try/1"><code>Kernel.SpecialForms.try/1</code></a> for more information</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#-/1">-value</a>
  </div>
  
    <div class="summary-synopsis"><p>Arithmetic unary minus</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#+/1">+value</a>
  </div>
  
    <div class="summary-synopsis"><p>Arithmetic unary plus</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#not/1">not arg</a>
  </div>
  
    <div class="summary-synopsis"><p>Boolean not</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_binary/1">is_binary(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a binary; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_bitstring/1">is_bitstring(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a bitstring (including a binary); otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_float/1">is_float(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a floating point number; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_function/1">is_function(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a function; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_list/1">is_list(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a list with zero or more elements; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_map/1">is_map(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a map; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_pid/1">is_pid(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a pid (process identifier); otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_port/1">is_port(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a port identifier; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_reference/1">is_reference(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a reference; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_tuple/1">is_tuple(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a tuple; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_atom/1">is_atom(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is an atom; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_integer/1">is_integer(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is an integer; otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_number/1">is_number(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is either an integer or a floating point number;
otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_boolean/1">is_boolean(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is either the atom <code>true</code> or the atom <code>false</code> (i.e.,
a boolean); otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#abs/1">abs(number)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns an integer or float which is the arithmetical absolute value of <code>number</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bit_size/1">bit_size(bitstring)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns an integer which is the size in bits of <code>bitstring</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#hd/1">hd(list)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the head of a list; raises <code>ArgumentError</code> if the list is empty</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#trunc/1">trunc(number)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the integer part of <code>number</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#length/1">length(list)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the length of <code>list</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#node/1">node(arg)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the node where the given argument is located.
The argument can be a pid, a reference, or a port.
If the local node is not alive, <code>:nonode@nohost</code> is returned</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#byte_size/1">byte_size(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the number of bytes needed to contain <code>bitstring</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#map_size/1">map_size(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the size of a map</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tuple_size/1">tuple_size(tuple)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the size of a tuple</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#tl/1">tl(list)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the tail of a list. Raises <code>ArgumentError</code> if the list is empty</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#round/1">round(number)</a>
  </div>
  
    <div class="summary-synopsis"><p>Rounds a number to the nearest integer</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#spawn/1">spawn(fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Spawns the given function and returns its pid</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#spawn_link/1">spawn_link(fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Spawns the given function, links it to the current process and returns its pid</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#spawn_monitor/1">spawn_monitor(fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Spawns the given function, monitors it and returns its pid
and monitoring reference</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#exit/1">exit(reason)</a>
  </div>
  
    <div class="summary-synopsis"><p>Stops the execution of the calling process with the given reason</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#+/2">left + right</a>
  </div>
  
    <div class="summary-synopsis"><p>Arithmetic addition</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#//2">left / right</a>
  </div>
  
    <div class="summary-synopsis"><p>Arithmetic division</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#*/2">left * right</a>
  </div>
  
    <div class="summary-synopsis"><p>Arithmetic multiplication</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#-/2">left - right</a>
  </div>
  
    <div class="summary-synopsis"><p>Arithmetic subtraction</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#rem/2">rem(left, right)</a>
  </div>
  
    <div class="summary-synopsis"><p>Computes the remainder of an integer division</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#++/2">left ++ right</a>
  </div>
  
    <div class="summary-synopsis"><p>Concatenates two lists</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#struct/2">struct(struct, kv \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates and updates structs</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_in/2">get_in(data, keys)</a>
  </div>
  
    <div class="summary-synopsis"><p>Gets a value from a nested structure</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#elem/2">elem(tuple, index)</a>
  </div>
  
    <div class="summary-synopsis"><p>Gets the element at the zero-based <code>index</code> in <code>tuple</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#inspect/2">inspect(arg, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Inspects the given argument according to the <code>Inspect</code> protocol.
The second argument is a keyword list with options to control
inspection</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#apply/2">apply(fun, args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Invokes the given <code>fun</code> with the array of arguments <code>args</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#=~/2">left =~ right</a>
  </div>
  
    <div class="summary-synopsis"><p>Matches the term on the left against the regular expression or string on the
right. Returns <code>true</code> if <code>left</code> matches <code>right</code> (if it&#39;s a regular expression)
or contains <code>right</code> (if it&#39;s a string)</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#div/2">div(left, right)</a>
  </div>
  
    <div class="summary-synopsis"><p>Performs an integer division</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#--/2">left -- right</a>
  </div>
  
    <div class="summary-synopsis"><p>Removes the first occurrence of an item on the left list
for each item on the right</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_function/2">is_function(term, arity)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is a function that can be applied with <code>arity</code> number of arguments;
otherwise returns <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&lt;=/2">left &lt;= right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if left is less than or equal to right</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&lt;/2">left &lt; right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if left is less than right</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&gt;=/2">left &gt;= right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if left is more than or equal to right</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&gt;/2">left &gt; right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if left is more than right</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#==/2">left == right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if the two items are equal</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#===/2">left === right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if the two items are match</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#!=/2">left != right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if the two items are not equal</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#!==/2">left !== right</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if the two items do not match</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#max/2">max(first, second)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the biggest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#min/2">min(first, second)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the smallest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#send/2">send(dest, msg)</a>
  </div>
  
    <div class="summary-synopsis"><p>Sends a message to the given <code>dest</code> and returns the message</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binary_part/3">binary_part(binary, start, length)</a>
  </div>
  
    <div class="summary-synopsis"><p>Extracts the part of the binary starting at <code>start</code> with length <code>length</code>.
Binaries are zero-indexed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_and_update_in/3">get_and_update_in(data, keys, fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Gets a value and updates a nested structure</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#put_elem/3">put_elem(tuple, index, value)</a>
  </div>
  
    <div class="summary-synopsis"><p>Inserts <code>value</code> at the given zero-based <code>index</code> in <code>tuple</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#apply/3">apply(module, fun, args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Invokes the given <code>fun</code> from <code>module</code> with the array of arguments <code>args</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#put_in/3">put_in(data, keys, value)</a>
  </div>
  
    <div class="summary-synopsis"><p>Puts a value in a nested structure</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#function_exported?/3">function_exported?(module, function, arity)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>module</code> is loaded and contains a
public <code>function</code> with the given <code>arity</code>, otherwise <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#macro_exported?/3">macro_exported?(module, macro, arity)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>module</code> is loaded and contains a
public <code>macro</code> with the given <code>arity</code>, otherwise <code>false</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#spawn/3">spawn(module, fun, args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Spawns the given module and function passing the given args
and returns its pid</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#spawn_link/3">spawn_link(module, fun, args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Spawns the given module and function passing the given args,
links it to the current process and returns its pid</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#spawn_monitor/3">spawn_monitor(module, fun, args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Spawns the given module and function passing the given args,
monitors it and returns its pid and monitoring reference</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#update_in/3">update_in(data, keys, fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Updates a key in a nested structure</p>
</div>
  
</div>

  </div>


          
  <div class="summary-macros summary">
    <h2>
      <a href="#macros_details">Macros</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#!/1">!arg</a>
  </div>
  
    <div class="summary-synopsis"><p>Boolean not</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_char_list/1">to_char_list(arg)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts the argument to a char list according to the <code>List.Chars</code> protocol</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_string/1">to_string(arg)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts the argument to a string according to the
<code>String.Chars</code> protocol</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defstruct/1">defstruct(fields)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defexception/1">defexception(fields)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines an exception</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defoverridable/1">defoverridable(keywords)</a>
  </div>
  
    <div class="summary-synopsis"><p>Makes the given functions in the current module overridable</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#raise/1">raise(msg)</a>
  </div>
  
    <div class="summary-synopsis"><p>Raises an exception</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#@/1">@expr</a>
  </div>
  
    <div class="summary-synopsis"><p>Reads and writes attributes of the current module</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#is_nil/1">is_nil(term)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>term</code> is <code>nil</code>, <code>false</code> otherwise</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#binding/1">binding(context \\ nil)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the binding for the given context as a keyword list</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#alias!/1">alias!(alias)</a>
  </div>
  
    <div class="summary-synopsis"><p>When used inside quoting, marks that the given alias should not
be hygienized. This means the alias will be expanded when
the macro is expanded</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match?/2">match?(pattern, expr)</a>
  </div>
  
    <div class="summary-synopsis"><p>A convenience macro that checks if the right side (an expression) matches the
left side (a pattern)</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#and/2">left and right</a>
  </div>
  
    <div class="summary-synopsis"><p>Boolean and</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#or/2">left or right</a>
  </div>
  
    <div class="summary-synopsis"><p>Boolean or</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#in/2">left in right</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks if the element on the left-hand side is a member of the
collection on the right-hand side</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&lt;&gt;/2">left &lt;&gt; right</a>
  </div>
  
    <div class="summary-synopsis"><p>Concatenates two binaries</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defdelegate/2">defdelegate(funs, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a function that delegates to another module</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#def/2">def(call, expr \\ nil)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a function with the given name and body</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defmacro/2">defmacro(call, expr \\ nil)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a macro with the given name and body</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defmodule/2">defmodule(alias, list)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a module given by name with the given contents</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defp/2">defp(call, expr \\ nil)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a private function with the given name and body</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defmacrop/2">defmacrop(call, expr \\ nil)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a private macro with the given name and body</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defprotocol/2">defprotocol(name, list)</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a protocol</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#destructure/2">destructure(left, right)</a>
  </div>
  
    <div class="summary-synopsis"><p>Destructures two lists, assigning each term in the
right one to the matching term in the left one</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#get_and_update_in/2">get_and_update_in(path, fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Gets a value and updates a nested data structure via the given <code>path</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_C/2">sigil_C(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~C</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_R/2">sigil_R(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~R</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_S/2">sigil_S(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~S</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_W/2">sigil_W(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~W</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_c/2">sigil_c(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~c</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_r/2">sigil_r(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~r</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_s/2">sigil_s(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~s</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#sigil_w/2">sigil_w(term, modifiers)</a>
  </div>
  
    <div class="summary-synopsis"><p>Handles the sigil <code>~w</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#|&gt;/2">left |&gt; right</a>
  </div>
  
    <div class="summary-synopsis"><p>Pipe operator</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&amp;&amp;/2">left &amp;&amp; right</a>
  </div>
  
    <div class="summary-synopsis"><p>Provides a short-circuit operator that evaluates and returns
the second expression only if the first one evaluates to <code>true</code>
(i.e., it is not <code>nil</code> nor <code>false</code>). Returns the first expression
otherwise</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#||/2">left || right</a>
  </div>
  
    <div class="summary-synopsis"><p>Provides a short-circuit operator that evaluates and returns the second
expression only if the first one does not evaluate to <code>true</code> (i.e., it
is either <code>nil</code> or <code>false</code>). Returns the first expression otherwise</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#if/2">if(condition, clauses)</a>
  </div>
  
    <div class="summary-synopsis"><p>Provides an <code>if</code> macro</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#unless/2">unless(condition, clauses)</a>
  </div>
  
    <div class="summary-synopsis"><p>Provides an <code>unless</code> macro</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#put_in/2">put_in(path, value)</a>
  </div>
  
    <div class="summary-synopsis"><p>Puts a value in a nested structure via the given <code>path</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#reraise/2">reraise(msg, stacktrace)</a>
  </div>
  
    <div class="summary-synopsis"><p>Raises an exception preserving a previous stacktrace</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#raise/2">raise(exception, attrs)</a>
  </div>
  
    <div class="summary-synopsis"><p>Raises an exception</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#../2">first .. last</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a range with the specified start and end</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#update_in/2">update_in(path, fun)</a>
  </div>
  
    <div class="summary-synopsis"><p>Updates a nested structure via the given <code>path</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#use/2">use(module, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Uses the given module in the current context</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#var!/2">var!(var, context \\ nil)</a>
  </div>
  
    <div class="summary-synopsis"><p>When used inside quoting, marks that the given variable should
not be hygienized</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#defimpl/3">defimpl(name, opts, do_block \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines an implementation for the given protocol</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#reraise/3">reraise(exception, attrs, stacktrace)</a>
  </div>
  
    <div class="summary-synopsis"><p>Raises an exception preserving a previous stacktrace</p>
</div>
  
</div>

  </div>


          

        </section>
      

      

      
        <section id="functions_details" class="details-list">
          <h1 class="section-heading">Functions</h1>
          <div class="detail">
  <div class="detail-header" id="!=/2">
    <a href="#!=/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left != right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term != term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if the two items are not equal.</p>

<p>This operator considers 1 and 1.0 to be equal. For match
comparison, use <code>!==</code> instead.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 != 2
true

iex&gt; 1 != 1.0
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="!==/2">
    <a href="#!==/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left !== right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term !== term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if the two items do not match.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 !== 2
true

iex&gt; 1 !== 1.0
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="*/2">
    <a href="#*/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left * right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">number * number :: number</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Arithmetic multiplication.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 * 2
2
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="+/1">
    <a href="#+/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">+value</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">+number :: number</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Arithmetic unary plus.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; +1
1
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="+/2">
    <a href="#+/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left + right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">number + number :: number</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Arithmetic addition.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 + 2
3
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="++/2">
    <a href="#++/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left ++ right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">list ++ term :: maybe_improper_list</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Concatenates two lists.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; [1] ++ [2, 3]
[1, 2, 3]

iex&gt; &#39;foo&#39; ++ &#39;bar&#39;
&#39;foobar&#39;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="-/1">
    <a href="#-/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">-value</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">-number :: number</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Arithmetic unary minus.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; -2
-2
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="-/2">
    <a href="#-/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left - right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">number - number :: number</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Arithmetic subtraction.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 - 2
-1
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="--/2">
    <a href="#--/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left -- right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">list -- list :: list</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Removes the first occurrence of an item on the left list
for each item on the right.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; [1, 2, 3] -- [1, 2]
[3]

iex&gt; [1, 2, 3, 2, 1] -- [1, 2, 2]
[3, 1]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="//2">
    <a href="#//2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left / right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">number / number :: float</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Arithmetic division.</p>

<p>The result is always a float. Use <a href="#div/2"><code>div/2</code></a> and <a href="#rem/2"><code>rem/2</code></a> if you want
an integer division or the remainder.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 / 2
0.5

iex&gt; 2 / 1
2.0
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&lt;/2">
    <a href="#&lt;/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left &lt; right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term < term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if left is less than right.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 &lt; 2
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&lt;=/2">
    <a href="#&lt;=/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left &lt;= right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term <= term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if left is less than or equal to right.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 &lt;= 2
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="==/2">
    <a href="#==/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left == right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term == term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if the two items are equal.</p>

<p>This operator considers 1 and 1.0 to be equal. For match
semantics, use <code>===</code> instead.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 == 2
false

iex&gt; 1 == 1.0
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="===/2">
    <a href="#===/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left === right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term === term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if the two items are match.</p>

<p>This operator gives the same semantics as the one existing in
pattern matching, i.e., <code>1</code> and <code>1.0</code> are equal, but they do
not match.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 === 2
false

iex&gt; 1 === 1.0
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="=~/2">
    <a href="#=~/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left =~ right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir"><a href="String.html#t:t/0">String.t</a> =~ (<a href="String.html#t:t/0">String.t</a> | Regex.t) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Matches the term on the left against the regular expression or string on the
right. Returns <code>true</code> if <code>left</code> matches <code>right</code> (if it&#39;s a regular expression)
or contains <code>right</code> (if it&#39;s a string).</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; &quot;abcd&quot; =~ ~r/c(d)/
true

iex&gt; &quot;abcd&quot; =~ ~r/e/
false

iex&gt; &quot;abcd&quot; =~ &quot;bc&quot;
true

iex&gt; &quot;abcd&quot; =~ &quot;ad&quot;
false

iex&gt; &quot;abcd&quot; =~ &quot;&quot;
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&gt;/2">
    <a href="#&gt;/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left &gt; right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term > term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if left is more than right.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 &gt; 2
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&gt;=/2">
    <a href="#&gt;=/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left &gt;= right</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">term >= term :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if left is more than or equal to right.</p>

<p>All terms in Elixir can be compared with each other.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 1 &gt;= 2
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="abs/1">
    <a href="#abs/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">abs(number)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">abs(number) :: number</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns an integer or float which is the arithmetical absolute value of <code>number</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; abs(-3.33)
3.33

iex&gt; abs(-3)
3
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="apply/2">
    <a href="#apply/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">apply(fun, args)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">apply((... -> any), [any]) :: any</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Invokes the given <code>fun</code> with the array of arguments <code>args</code>.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; apply(fn x -&gt; x * 2 end, [2])
4
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="apply/3">
    <a href="#apply/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">apply(module, fun, args)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">apply(module, atom, [any]) :: any</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Invokes the given <code>fun</code> from <code>module</code> with the array of arguments <code>args</code>.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; apply(Enum, :reverse, [[1, 2, 3]])
[3, 2, 1]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="binary_part/3">
    <a href="#binary_part/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">binary_part(binary, start, length)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">binary_part(binary, pos_integer, integer) :: binary</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Extracts the part of the binary starting at <code>start</code> with length <code>length</code>.
Binaries are zero-indexed.</p>

<p>If <code>start</code> or <code>length</code> reference in any way outside the binary, an
<code>ArgumentError</code> exception is raised.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; binary_part(&quot;foo&quot;, 1, 2)
&quot;oo&quot;
</code></pre>

<p>A negative <code>length</code> can be used to extract bytes that come <em>before</em> the byte
at <code>start</code>:</p>

<pre><code class="iex elixir">iex&gt; binary_part(&quot;Hello&quot;, 5, -3)
&quot;llo&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="bit_size/1">
    <a href="#bit_size/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">bit_size(bitstring)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">bit_size(bitstring) :: non_neg_integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns an integer which is the size in bits of <code>bitstring</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; bit_size(&lt;&lt;433::16, 3::3&gt;&gt;)
19

iex&gt; bit_size(&lt;&lt;1, 2, 3&gt;&gt;)
24
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="byte_size/1">
    <a href="#byte_size/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">byte_size(binary)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">byte_size(binary) :: non_neg_integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the number of bytes needed to contain <code>bitstring</code>.</p>

<p>That is, if the number of bits in <code>bitstring</code> is not divisible by 8, the
resulting number of bytes will be rounded up (by excess). This operation
happens in constant time.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; byte_size(&lt;&lt;433::16, 3::3&gt;&gt;)
3

iex&gt; byte_size(&lt;&lt;1, 2, 3&gt;&gt;)
3
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="div/2">
    <a href="#div/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">div(left, right)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">div(integer, integer) :: integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Performs an integer division.</p>

<p>Raises an <code>ArithmeticError</code> exception if one of the arguments is not an
integer.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; div(5, 2)
2
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="elem/2">
    <a href="#elem/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">elem(tuple, index)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">elem(tuple, non_neg_integer) :: term</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Gets the element at the zero-based <code>index</code> in <code>tuple</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; tuple = {:foo, :bar, 3}
iex&gt; elem(tuple, 1)
:bar
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="exit/1">
    <a href="#exit/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">exit(reason)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">exit(term) :: no_return</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Stops the execution of the calling process with the given reason.</p>

<p>Since evaluating this function causes the process to terminate,
it has no return value.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<p>When a process reaches its end, by default it exits with
reason <code>:normal</code>. You can also call <a href="#exit/1"><code>exit/1</code></a> explicitly if you
want to terminate a process but not signal any failure:</p>

<pre><code class="elixir">exit(:normal)
</code></pre>

<p>In case something goes wrong, you can also use <a href="#exit/1"><code>exit/1</code></a> with
a different reason:</p>

<pre><code class="elixir">exit(:seems_bad)
</code></pre>

<p>If the exit reason is not <code>:normal</code>, all the processes linked to the process
that exited will crash (unless they are trapping exits).</p>

<h2>OTP exits</h2>

<p>Exits are used by the OTP to determine if a process exited abnormally
or not. The following exits are considered &quot;normal&quot;:</p>

<ul>
<li><code>exit(:normal)</code></li>
<li><code>exit(:shutdown)</code></li>
<li><code>exit({:shutdown, term})</code></li>
</ul>

<p>Exiting with any other reason is considered abnormal and treated
as a crash. This means the default supervisor behaviour kicks in,
error reports are emitted, etc.</p>

<p>This behaviour is relied on in many different places. For example,
<code>ExUnit</code> uses <code>exit(:shutdown)</code> when exiting the test process to
signal linked processes, supervision trees and so on to politely
shutdown too.</p>

<h2>CLI exits</h2>

<p>Building on top of the exit signals mentioned above, if the
process started by the command line exits with any of the three
reasons above, its exit is considered normal and the Operating
System process will exit with status 0.</p>

<p>It is, however, possible to customize the Operating System exit
signal by invoking:</p>

<pre><code class="elixir">exit({:shutdown, integer})
</code></pre>

<p>This will cause the OS process to exit with the status given by
<code>integer</code> while signaling all linked OTP processes to politely
shutdown.</p>

<p>Any other exit reason will cause the OS process to exit with
status <code>1</code> and linked OTP processes to crash.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="function_exported?/3">
    <a href="#function_exported?/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">function_exported?(module, function, arity)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">function_exported?(atom | tuple, atom, arity) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>module</code> is loaded and contains a
public <code>function</code> with the given <code>arity</code>, otherwise <code>false</code>.</p>

<p>Note that this function does not load the module in case
it is not loaded. Check <code>Code.ensure_loaded/1</code> for more
information.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; function_exported?(Enum, :member?, 2)
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="get_and_update_in/3">
    <a href="#get_and_update_in/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">get_and_update_in(data, keys, fun)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">get_and_update_in(Access.t, [term, ...], (term -> {get, term})) :: {get, Access.t} when get: var</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Gets a value and updates a nested structure.</p>

<p>It expects a tuple to be returned, containing the value
retrieved and the update one.</p>

<p>Uses the <code>Access</code> protocol to traverse the structures
according to the given <code>keys</code>, unless the <code>key</code> is a
function.</p>

<p>If a key is a function, the function will be invoked
passing three arguments, the operation (<code>:get_and_update</code>),
the data to be accessed, and a function to be invoked next.</p>

<p>This means <a href="#get_and_update_in/3"><code>get_and_update_in/3</code></a> can be extended to provide
custom lookups. The downside is that functions cannot be stored
as keys in the accessed data structures.</p>

<h2>Examples</h2>

<p>This function is useful when there is a need to retrieve the current
value (or something calculated in function of the current value) and
update it at the same time. For example, it could be used to increase
the age of a user by one and return the previous age in one pass:</p>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; get_and_update_in(users, [&quot;john&quot;, :age], &amp;{&amp;1, &amp;1 + 1})
{27, %{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}}
</code></pre>

<p>When one of the keys is a function, the function is invoked.
In the example below, we use a function to get and increment all
ages inside a list:</p>

<pre><code class="iex elixir">iex&gt; users = [%{name: &quot;john&quot;, age: 27}, %{name: &quot;meg&quot;, age: 23}]
iex&gt; all = fn :get_and_update, data, next -&gt;
...&gt;   Enum.map(data, next) |&gt; :lists.unzip
...&gt; end
iex&gt; get_and_update_in(users, [all, :age], &amp;{&amp;1, &amp;1 + 1})
{[27, 23], [%{name: &quot;john&quot;, age: 28}, %{name: &quot;meg&quot;, age: 24}]}
</code></pre>

<p>If the previous value before invoking the function is <code>nil</code>,
the function <em>will</em> receive <code>nil</code> as a value and must handle it
accordingly (be it by failing or providing a sane default).</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="get_in/2">
    <a href="#get_in/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">get_in(data, keys)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">get_in(Access.t, [term, ...]) :: term</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Gets a value from a nested structure.</p>

<p>Uses the <code>Access</code> protocol to traverse the structures
according to the given <code>keys</code>, unless the <code>key</code> is a
function.</p>

<p>If a key is a function, the function will be invoked
passing three arguments, the operation (<code>:get</code>), the
data to be accessed, and a function to be invoked next.</p>

<p>This means <a href="#get_in/2"><code>get_in/2</code></a> can be extended to provide
custom lookups. The downside is that functions cannot be
stored as keys in the accessed data structures.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; get_in(users, [&quot;john&quot;, :age])
27
</code></pre>

<p>In case any of entries in the middle returns <code>nil</code>, <code>nil</code> will be returned
as per the Access protocol:</p>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; get_in(users, [&quot;unknown&quot;, :age])
nil
</code></pre>

<p>When one of the keys is a function, the function is invoked.
In the example below, we use a function to get all the maps
inside a list:</p>

<pre><code class="iex elixir">iex&gt; users = [%{name: &quot;john&quot;, age: 27}, %{name: &quot;meg&quot;, age: 23}]
iex&gt; all = fn :get, data, next -&gt; Enum.map(data, next) end
iex&gt; get_in(users, [all, :age])
[27, 23]
</code></pre>

<p>If the previous value before invoking the function is <code>nil</code>,
the function <em>will</em> receive nil as a value and must handle it
accordingly.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="hd/1">
    <a href="#hd/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">hd(list)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">hd(list) :: term</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the head of a list; raises <code>ArgumentError</code> if the list is empty.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; hd([1, 2, 3, 4])
1
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="inspect/2">
    <a href="#inspect/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">inspect(arg, opts \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">inspect(Inspect.t, Keyword.t) :: <a href="String.html#t:t/0">String.t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Inspects the given argument according to the <code>Inspect</code> protocol.
The second argument is a keyword list with options to control
inspection.</p>

<h2>Options</h2>

<p><a href="#inspect/2"><code>inspect/2</code></a> accepts a list of options that are internally
translated to an <code>Inspect.Opts</code> struct. Check the docs for
<code>Inspect.Opts</code> to see the supported options.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; inspect(:foo)
&quot;:foo&quot;

iex&gt; inspect [1, 2, 3, 4, 5], limit: 3
&quot;[1, 2, 3, ...]&quot;

iex&gt; inspect(&quot;olÃ¡&quot; &lt;&gt; &lt;&lt;0&gt;&gt;)
&quot;&lt;&lt;111, 108, 195, 161, 0&gt;&gt;&quot;

iex&gt; inspect(&quot;olÃ¡&quot; &lt;&gt; &lt;&lt;0&gt;&gt;, binaries: :as_strings)
&quot;\&quot;olÃ¡\\0\&quot;&quot;

iex&gt; inspect(&quot;olÃ¡&quot;, binaries: :as_binaries)
&quot;&lt;&lt;111, 108, 195, 161&gt;&gt;&quot;

iex&gt; inspect(&#39;bar&#39;)
&quot;&#39;bar&#39;&quot;

iex&gt; inspect([0|&#39;bar&#39;])
&quot;[0, 98, 97, 114]&quot;

iex&gt; inspect(100, base: :octal)
&quot;0o144&quot;

iex&gt; inspect(100, base: :hex)
&quot;0x64&quot;
</code></pre>

<p>Note that the <code>Inspect</code> protocol does not necessarily return a valid
representation of an Elixir term. In such cases, the inspected result
must start with <code>#</code>. For example, inspecting a function will return:</p>

<pre><code class="elixir">inspect fn a, b -&gt; a + b end
#=&gt; #Function&lt;...&gt;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_atom/1">
    <a href="#is_atom/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_atom(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_atom(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is an atom; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_binary/1">
    <a href="#is_binary/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_binary(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_binary(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a binary; otherwise returns <code>false</code>.</p>

<p>A binary always contains a complete number of bytes.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; is_binary &quot;foo&quot;
true
iex&gt; is_binary &lt;&lt;1::3&gt;&gt;
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_bitstring/1">
    <a href="#is_bitstring/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_bitstring(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_bitstring(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a bitstring (including a binary); otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; is_bitstring &quot;foo&quot;
true
iex&gt; is_bitstring &lt;&lt;1::3&gt;&gt;
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_boolean/1">
    <a href="#is_boolean/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_boolean(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_boolean(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is either the atom <code>true</code> or the atom <code>false</code> (i.e.,
a boolean); otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_float/1">
    <a href="#is_float/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_float(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_float(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a floating point number; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_function/1">
    <a href="#is_function/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_function(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_function(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a function; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_function/2">
    <a href="#is_function/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_function(term, arity)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_function(term, non_neg_integer) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a function that can be applied with <code>arity</code> number of arguments;
otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; is_function(fn(x) -&gt; x * 2 end, 1)
true
iex&gt; is_function(fn(x) -&gt; x * 2 end, 2)
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_integer/1">
    <a href="#is_integer/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_integer(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_integer(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is an integer; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_list/1">
    <a href="#is_list/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_list(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_list(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a list with zero or more elements; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_map/1">
    <a href="#is_map/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_map(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_map(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a map; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_number/1">
    <a href="#is_number/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_number(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_number(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is either an integer or a floating point number;
otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_pid/1">
    <a href="#is_pid/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_pid(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_pid(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a pid (process identifier); otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_port/1">
    <a href="#is_port/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_port(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_port(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a port identifier; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_reference/1">
    <a href="#is_reference/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_reference(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_reference(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a reference; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_tuple/1">
    <a href="#is_tuple/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_tuple(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">is_tuple(term) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is a tuple; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="length/1">
    <a href="#length/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">length(list)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">length(list) :: non_neg_integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the length of <code>list</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])
9
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="macro_exported?/3">
    <a href="#macro_exported?/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">macro_exported?(module, macro, arity)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">macro_exported?(atom, atom, integer) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>module</code> is loaded and contains a
public <code>macro</code> with the given <code>arity</code>, otherwise <code>false</code>.</p>

<p>Note that this function does not load the module in case
it is not loaded. Check <code>Code.ensure_loaded/1</code> for more
information.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; macro_exported?(Kernel, :use, 2)
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="make_ref/0">
    <a href="#make_ref/0" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">make_ref()</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">make_ref :: reference</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns an almost unique reference.</p>

<p>The returned reference will re-occur after approximately 2^82 calls;
therefore it is unique enough for practical purposes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">make_ref() #=&gt; #Reference&lt;0.0.0.135&gt;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="map_size/1">
    <a href="#map_size/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">map_size(map)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">map_size(map) :: non_neg_integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the size of a map.</p>

<p>The size of a map is the number of key-value pairs that the map contains.</p>

<p>This operation happens in constant time.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; map_size(%{a: &quot;foo&quot;, b: &quot;bar&quot;})
2
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="max/2">
    <a href="#max/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">max(first, second)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">max(term, term) :: term</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the biggest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; max(1, 2)
2
iex&gt; max(:a, :b)
:b
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="min/2">
    <a href="#min/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">min(first, second)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">min(term, term) :: term</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the smallest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; min(1, 2)
1
iex&gt; min(&quot;foo&quot;, &quot;bar&quot;)
&quot;bar&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="node/0">
    <a href="#node/0" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">node()</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">node :: node</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns an atom representing the name of the local node.
If the node is not alive, <code>:nonode@nohost</code> is returned instead.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="node/1">
    <a href="#node/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">node(arg)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">node(pid | reference | port) :: node</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the node where the given argument is located.
The argument can be a pid, a reference, or a port.
If the local node is not alive, <code>:nonode@nohost</code> is returned.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="not/1">
    <a href="#not/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">not arg</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">not boolean :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Boolean not.</p>

<p><code>arg</code> must be a boolean; if it&#39;s not, an <code>ArgumentError</code> exception is raised.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; not false
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="put_elem/3">
    <a href="#put_elem/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">put_elem(tuple, index, value)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">put_elem(tuple, non_neg_integer, term) :: tuple</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Inserts <code>value</code> at the given zero-based <code>index</code> in <code>tuple</code>.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; tuple = {:foo, :bar, 3}
iex&gt; put_elem(tuple, 0, :baz)
{:baz, :bar, 3}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="put_in/3">
    <a href="#put_in/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">put_in(data, keys, value)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">put_in(Access.t, [term, ...], term) :: Access.t</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Puts a value in a nested structure.</p>

<p>Uses the <code>Access</code> protocol to traverse the structures
according to the given <code>keys</code>, unless the <code>key</code> is a
function. If the key is a function, it will be invoked
as specified in <a href="#get_and_update_in/3"><code>get_and_update_in/3</code></a>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; put_in(users, [&quot;john&quot;, :age], 28)
%{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}
</code></pre>

<p>In case any of entries in the middle returns <code>nil</code>,
an error will be raised when trying to access it next.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="rem/2">
    <a href="#rem/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">rem(left, right)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">rem(integer, integer) :: integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Computes the remainder of an integer division.</p>

<p>Raises an <code>ArithmeticError</code> exception if one of the arguments is not an
integer.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; rem(5, 2)
1
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="round/1">
    <a href="#round/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">round(number)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">round(number) :: integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Rounds a number to the nearest integer.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; round(5.6)
6
iex&gt; round(5.2)
5
iex&gt; round(-9.9)
-10
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="self/0">
    <a href="#self/0" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">self()</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">self :: pid</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the pid (process identifier) of the calling process.</p>

<p>Allowed in guard clauses. Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="send/2">
    <a href="#send/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">send(dest, msg)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">send(dest :: pid | port | atom | {atom, node}, msg) :: msg when msg: any</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Sends a message to the given <code>dest</code> and returns the message.</p>

<p><code>dest</code> may be a remote or local pid, a (local) port, a locally
registered name, or a tuple <code>{registered_name, node}</code> for a registered
name at another node.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; send self(), :hello
:hello
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="spawn/1">
    <a href="#spawn/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">spawn(fun)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">spawn((() -> any)) :: pid</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Spawns the given function and returns its pid.</p>

<p>Check the <code>Process</code> and <code>Node</code> modules for other functions
to handle processes, including spawning functions in nodes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">current = self()
child   = spawn(fn -&gt; send current, {self(), 1 + 2} end)

receive do
  {^child, 3} -&gt; IO.puts &quot;Received 3 back&quot;
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="spawn/3">
    <a href="#spawn/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">spawn(module, fun, args)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">spawn(module, atom, list) :: pid</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Spawns the given module and function passing the given args
and returns its pid.</p>

<p>Check the <code>Process</code> and <code>Node</code> modules for other functions
to handle processes, including spawning functions in nodes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">spawn(SomeModule, :function, [1, 2, 3])
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="spawn_link/1">
    <a href="#spawn_link/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">spawn_link(fun)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">spawn_link((() -> any)) :: pid</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Spawns the given function, links it to the current process and returns its pid.</p>

<p>Check the <code>Process</code> and <code>Node</code> modules for other functions
to handle processes, including spawning functions in nodes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">current = self()
child   = spawn_link(fn -&gt; send current, {self(), 1 + 2} end)

receive do
  {^child, 3} -&gt; IO.puts &quot;Received 3 back&quot;
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="spawn_link/3">
    <a href="#spawn_link/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">spawn_link(module, fun, args)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">spawn_link(module, atom, list) :: pid</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Spawns the given module and function passing the given args,
links it to the current process and returns its pid.</p>

<p>Check the <code>Process</code> and <code>Node</code> modules for other functions
to handle processes, including spawning functions in nodes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">spawn_link(SomeModule, :function, [1, 2, 3])
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="spawn_monitor/1">
    <a href="#spawn_monitor/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">spawn_monitor(fun)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">spawn_monitor((() -> any)) :: {pid, reference}</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Spawns the given function, monitors it and returns its pid
and monitoring reference.</p>

<p>Check the <code>Process</code> and <code>Node</code> modules for other functions
to handle processes, including spawning functions in nodes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">current = self()
spawn_monitor(fn -&gt; send current, {self(), 1 + 2} end)
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="spawn_monitor/3">
    <a href="#spawn_monitor/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">spawn_monitor(module, fun, args)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">spawn_monitor(module, atom, list) :: {pid, reference}</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Spawns the given module and function passing the given args,
monitors it and returns its pid and monitoring reference.</p>

<p>Check the <code>Process</code> and <code>Node</code> modules for other functions
to handle processes, including spawning functions in nodes.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="elixir">spawn_monitor(SomeModule, :function, [1, 2, 3])
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="struct/2">
    <a href="#struct/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">struct(struct, kv \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">struct(module | map, Enum.t) :: map</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Creates and updates structs.</p>

<p>The <code>struct</code> argument may be an atom (which defines <code>defstruct</code>)
or a <code>struct</code> itself. The second argument is any <code>Enumerable</code> that
emits two-item tuples (key-value pairs) during enumeration.</p>

<p>Keys in the <code>Enumerable</code> that don&#39;t exist in the struct are automatically
discarded.</p>

<p>This function is useful for dynamically creating and updating
structs, as well as for converting maps to structs; in the latter case, just
inserting the appropriate <code>:__struct__</code> field into the map may not be enough
and <a href="#struct/2"><code>struct/2</code></a> should be used instead.</p>

<h2>Examples</h2>

<pre><code class="elixir">defmodule User do
  defstruct name: &quot;john&quot;
end

struct(User)
#=&gt; %User{name: &quot;john&quot;}

opts = [name: &quot;meg&quot;]
user = struct(User, opts)
#=&gt; %User{name: &quot;meg&quot;}

struct(user, unknown: &quot;value&quot;)
#=&gt; %User{name: &quot;meg&quot;}

struct(User, %{name: &quot;meg&quot;})
#=&gt; %User{name: &quot;meg&quot;}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="throw/1">
    <a href="#throw/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">throw(term)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">throw(term) :: no_return</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>A non-local return from a function. Check <a href="Kernel.SpecialForms.html#try/1"><code>Kernel.SpecialForms.try/1</code></a> for more information.</p>

<p>Inlined by the compiler.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="tl/1">
    <a href="#tl/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">tl(list)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">tl(maybe_improper_list) :: maybe_improper_list</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the tail of a list. Raises <code>ArgumentError</code> if the list is empty.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; tl([1, 2, 3, :go])
[2, 3, :go]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="trunc/1">
    <a href="#trunc/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">trunc(number)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">trunc(number) :: integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the integer part of <code>number</code>.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; trunc(5.4)
5
iex&gt; trunc(5.99)
5
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="tuple_size/1">
    <a href="#tuple_size/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">tuple_size(tuple)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">tuple_size(tuple) :: non_neg_integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the size of a tuple.</p>

<p>This operation happens in constant time.</p>

<p>Allowed in guard tests. Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; tuple_size {:a, :b, :c}
3
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="update_in/3">
    <a href="#update_in/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">update_in(data, keys, fun)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">update_in(Access.t, [term, ...], (term -> term)) :: Access.t</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Updates a key in a nested structure.</p>

<p>Uses the <code>Access</code> protocol to traverse the structures
according to the given <code>keys</code>, unless the <code>key</code> is a
function. If the key is a function, it will be invoked
as specified in <a href="#get_and_update_in/3"><code>get_and_update_in/3</code></a>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; update_in(users, [&quot;john&quot;, :age], &amp;(&amp;1 + 1))
%{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}
</code></pre>

<p>In case any of entries in the middle returns <code>nil</code>,
an error will be raised when trying to access it next.</p>

  </section>
</div>

        </section>
      

      
        <section id="macros_details" class="details-list">
          <h1 class="section-heading">Macros</h1>
          <div class="detail">
  <div class="detail-header" id="!/1">
    <a href="#!/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">!arg</span>
      
  </div>
  
  <section class="docstring">
    <p>Boolean not.</p>

<p>Receives any argument (not just booleans) and returns <code>true</code> if the argument
is <code>false</code> or <code>nil</code>; returns <code>false</code> otherwise.</p>

<p>Not allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; !Enum.empty?([])
false

iex&gt; !List.first([])
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&amp;&amp;/2">
    <a href="#&amp;&amp;/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left &amp;&amp; right</span>
      
  </div>
  
  <section class="docstring">
    <p>Provides a short-circuit operator that evaluates and returns
the second expression only if the first one evaluates to <code>true</code>
(i.e., it is not <code>nil</code> nor <code>false</code>). Returns the first expression
otherwise.</p>

<p>Not allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; Enum.empty?([]) &amp;&amp; Enum.empty?([])
true

iex&gt; List.first([]) &amp;&amp; true
nil

iex&gt; Enum.empty?([]) &amp;&amp; List.first([1])
1

iex&gt; false &amp;&amp; throw(:bad)
false
</code></pre>

<p>Note that, unlike Erlang&#39;s <code>and</code> operator,
this operator accepts any expression as the first argument,
not only booleans.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="../2">
    <a href="#../2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">first .. last</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns a range with the specified start and end.</p>

<p>Both ends are included.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; 0 in 1..3
false

iex&gt; 1 in 1..3
true

iex&gt; 2 in 1..3
true

iex&gt; 3 in 1..3
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="&lt;&gt;/2">
    <a href="#&lt;&gt;/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left &lt;&gt; right</span>
      
  </div>
  
  <section class="docstring">
    <p>Concatenates two binaries.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot;
&quot;foobar&quot;
</code></pre>

<p>The <code>&lt;&gt;</code> operator can also be used in pattern matching (and guard clauses) as
long as the first part is a literal binary:</p>

<pre><code class="iex elixir">iex&gt; &quot;foo&quot; &lt;&gt; x = &quot;foobar&quot;
iex&gt; x
&quot;bar&quot;
</code></pre>

<p><code>x &lt;&gt; &quot;bar&quot; = &quot;foobar&quot;</code> would have resulted in a <code>CompileError</code> exception.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="@/1">
    <a href="#@/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">@expr</span>
      
  </div>
  
  <section class="docstring">
    <p>Reads and writes attributes of the current module.</p>

<p>The canonical example for attributes is annotating that a module
implements the OTP behaviour called <code>gen_server</code>:</p>

<pre><code class="elixir">defmodule MyServer do
  @behaviour :gen_server
  # ... callbacks ...
end
</code></pre>

<p>By default Elixir supports all the module attributes supported by Erlang, but
custom attributes can be used as well:</p>

<pre><code class="elixir">defmodule MyServer do
  @my_data 13
  IO.inspect @my_data #=&gt; 13
end
</code></pre>

<p>Unlike Erlang, such attributes are not stored in the module by default since
it is common in Elixir to use custom attributes to store temporary data that
will be available at compile-time. Custom attributes may be configured to
behave closer to Erlang by using <code>Module.register_attribute/3</code>.</p>

<p>Finally, notice that attributes can also be read inside functions:</p>

<pre><code class="elixir">defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=&gt; 11
MyServer.second_data #=&gt; 13
</code></pre>

<p>It is important to note that reading an attribute takes a snapshot of
its current value. In other words, the value is read at compilation
time and not at runtime. Check the <code>Module</code> module for other functions
to manipulate module attributes.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="alias!/1">
    <a href="#alias!/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">alias!(alias)</span>
      
  </div>
  
  <section class="docstring">
    <p>When used inside quoting, marks that the given alias should not
be hygienized. This means the alias will be expanded when
the macro is expanded.</p>

<p>Check <a href="Kernel.SpecialForms.html#quote/2"><code>Kernel.SpecialForms.quote/2</code></a> for more information.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="and/2">
    <a href="#and/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left and right</span>
      
  </div>
  
  <section class="docstring">
    <p>Boolean and.</p>

<p>If the first argument is <code>false</code>, <code>false</code> is returned; otherwise, the second
argument is returned.</p>

<p>Requires only the first argument to be a boolean since it short-circuits. If
the first argument is not a boolean, an <code>ArgumentError</code> exception is raised.</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; true and false
false
iex&gt; true and &quot;yay!&quot;
&quot;yay!&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="binding/1">
    <a href="#binding/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">binding(context \\ nil)</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns the binding for the given context as a keyword list.</p>

<p>In the returned result, keys are variable names and values are the
corresponding variable values.</p>

<p>If the given <code>context</code> is <code>nil</code> (by default it is), the binding for the
current context is returned.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; binding()
[x: 1]
iex&gt; x = 2
iex&gt; binding()
[x: 2]

iex&gt; binding(:foo)
[]
iex&gt; var!(x, :foo) = 1
1
iex&gt; binding(:foo)
[x: 1]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="def/2">
    <a href="#def/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">def(call, expr \\ nil)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a function with the given name and body.</p>

<h2>Examples</h2>

<pre><code class="elixir">defmodule Foo do
  def bar, do: :baz
end

Foo.bar #=&gt; :baz
</code></pre>

<p>A function that expects arguments can be defined as follows:</p>

<pre><code class="elixir">defmodule Foo do
  def sum(a, b) do
    a + b
  end
end
</code></pre>

<p>In the example above, a <code>sum/2</code> function is defined; this function receives
two arguments and returns their sum.</p>

<h2>Function and variable names</h2>

<p>Function and variable names have the following syntax:
A <em>lowercase ASCII letter</em> or an <em>underscore</em>, followed by any number of
<em>lowercase or uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>.
Optionally they can end in either an <em>exclamation mark</em> or a <em>question mark</em>.</p>

<p>For variables, any identifier starting with an underscore should indicate an
unused variable. For example:</p>

<pre><code class="elixir">def foo(bar) do
  []
end
#=&gt; warning: variable bar is unused

def foo(_bar) do
  []
end
#=&gt; no warning

def foo(_bar) do
  _bar
end
#=&gt; warning: the underscored variable &quot;_bar&quot; is used after being set
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defdelegate/2">
    <a href="#defdelegate/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defdelegate(funs, opts)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a function that delegates to another module.</p>

<p>Functions defined with <a href="#defdelegate/2"><code>defdelegate/2</code></a> are public and can be invoked from
outside the module they&#39;re defined in (like if they were defined using
<a href="#def/2"><code>def/2</code></a>). When the desire is to delegate as private functions, <code>import</code> should
be used.</p>

<p>Delegation only works with functions; delegating macros is not supported.</p>

<h2>Options</h2>

<ul>
<li><p><code>:to</code> - the expression to delegate to. Any expression
is allowed and its results will be evaluated at runtime. Usually
evaluates to the name of a module.</p></li>
<li><p><code>:as</code> - the function to call on the target given in <code>:to</code>.
This parameter is optional and defaults to the name being
delegated (<code>funs</code>).</p></li>
<li><p><code>:append_first</code> - if <code>true</code>, when delegated, the first argument
passed to the delegated function will be relocated to the end of the
arguments when dispatched to the target.</p>

<p>The motivation behind this is because Elixir normalizes
the &quot;handle&quot; as the first argument while some Erlang modules
expect it as the last argument.</p></li>
</ul>

<h2>Examples</h2>

<pre><code class="elixir">defmodule MyList do
  defdelegate reverse(list), to: :lists
  defdelegate other_reverse(list), to: :lists, as: :reverse
  defdelegate [reverse(list), map(list, callback)], to: :lists, append_first: true
end

MyList.reverse([1, 2, 3])
#=&gt; [3, 2, 1]

MyList.other_reverse([1, 2, 3])
#=&gt; [3, 2, 1]

MyList.map([1, 2, 3], &amp;(&amp;1 * 2))
#=&gt; [2, 4, 6]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defexception/1">
    <a href="#defexception/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defexception(fields)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines an exception.</p>

<p>Exceptions are structs backed by a module that implements
the <code>Exception</code> behaviour. The <code>Exception</code> behaviour requires
two functions to be implemented:</p>

<ul>
<li><p><code>exception/1</code> - receives the arguments given to <a href="#raise/2"><code>raise/2</code></a>
and returns the exception struct. The default implementation
accepts either a set of keyword arguments that is merged into
the struct or a string to be used as the exception&#39;s message.</p></li>
<li><p><code>message/1</code> - receives the exception struct and must return its
message. Most commonly exceptions have a message field which
by default is accessed by this function. However, if an exception
does not have a message field, this function must be explicitly
implemented.</p></li>
</ul>

<p>Since exceptions are structs, the API supported by <a href="#defstruct/1"><code>defstruct/1</code></a>
is also available in <a href="#defexception/1"><code>defexception/1</code></a>.</p>

<h2>Raising exceptions</h2>

<p>The most common way to raise an exception is via <a href="#raise/2"><code>raise/2</code></a>:</p>

<pre><code class="elixir">defmodule MyAppError do
  defexception [:message]
end

value = [:hello]

raise MyAppError,
  message: &quot;did not get what was expected, got: #{inspect value}&quot;
</code></pre>

<p>In many cases it is more convenient to pass the expected value to
<a href="#raise/2"><code>raise/2</code></a> and generate the message in the <code>exception/1</code> callback:</p>

<pre><code class="elixir">defmodule MyAppError do
  defexception [:message]

  def exception(value) do
    msg = &quot;did not get what was expected, got: #{inspect value}&quot;
    %MyAppError{message: msg}
  end
end

raise MyAppError, value
</code></pre>

<p>The example above shows the preferred strategy for customizing
exception messages.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defimpl/3">
    <a href="#defimpl/3" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defimpl(name, opts, do_block \\ [])</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines an implementation for the given protocol.</p>

<p>See <a href="#defprotocol/2"><code>defprotocol/2</code></a> for more information and examples on protocols.</p>

<p>Inside an implementation, the name of the protocol can be accessed
via <code>@protocol</code> and the current target as <code>@for</code>.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defmacro/2">
    <a href="#defmacro/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defmacro(call, expr \\ nil)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a macro with the given name and body.</p>

<h2>Examples</h2>

<pre><code class="elixir">defmodule MyLogic do
  defmacro unless(expr, opts) do
    quote do
      if !unquote(expr), unquote(opts)
    end
  end
end

require MyLogic
MyLogic.unless false do
  IO.puts &quot;It works&quot;
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defmacrop/2">
    <a href="#defmacrop/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defmacrop(call, expr \\ nil)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a private macro with the given name and body.</p>

<p>Private macros are only accessible from the same module in which they are
defined.</p>

<p>Check <a href="#defmacro/2"><code>defmacro/2</code></a> for more information.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defmodule/2">
    <a href="#defmodule/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defmodule(alias, list)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a module given by name with the given contents.</p>

<p>This macro defines a module with the given <code>alias</code> as its name and with the
given contents. It returns a tuple with four elements:</p>

<ul>
<li><code>:module</code></li>
<li>the module name</li>
<li>the binary contents of the module</li>
<li>the result of evaluating the contents block</li>
</ul>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; defmodule Foo do
...&gt;   def bar, do: :baz
...&gt; end
iex&gt; Foo.bar
:baz
</code></pre>

<h2>Nesting</h2>

<p>Nesting a module inside another module affects the name of the nested module:</p>

<pre><code class="elixir">defmodule Foo do
  defmodule Bar do
  end
end
</code></pre>

<p>In the example above, two modules - <code>Foo</code> and <code>Foo.Bar</code> - are created.
When nesting, Elixir automatically creates an alias to the inner module,
allowing the second module <code>Foo.Bar</code> to be accessed as <code>Bar</code> in the same
lexical scope where it&#39;s defined (the <code>Foo</code> module).</p>

<p>If the <code>Foo.Bar</code> module is moved somewhere else, the references to <code>Bar</code> in
the <code>Foo</code> module need to be updated to the fully-qualified name (<code>Foo.Bar</code>) or
an alias has to be explicitly set in the <code>Foo</code> module with the help of
<a href="Kernel.SpecialForms.html#alias/2"><code>Kernel.SpecialForms.alias/2</code></a>.</p>

<pre><code class="elixir">defmodule Foo.Bar do
  # code
end

defmodule Foo do
  alias Foo.Bar
  # code here can refer to &quot;Foo.Bar&quot; as just &quot;Bar&quot;
end
</code></pre>

<h2>Module names</h2>

<p>A module name can be any atom, but Elixir provides a special syntax which is
usually used for module names. What is called a module name is an
<em>uppercase ASCII letter</em> followed by any number of <em>lowercase or
uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>.
This identifier is equivilant to an atom prefixed by <code>Elixir.</code>. So in the
<code>defmodule Foo</code> example <code>Foo</code> is equivalent to <code>:&quot;Elixir.Foo&quot;</code></p>

<h2>Dynamic names</h2>

<p>Elixir module names can be dynamically generated. This is very
useful when working with macros. For instance, one could write:</p>

<pre><code class="elixir">defmodule String.to_atom(&quot;Foo#{1}&quot;) do
  # contents ...
end
</code></pre>

<p>Elixir will accept any module name as long as the expression passed as the
first argument to <a href="#defmodule/2"><code>defmodule/2</code></a> evaluates to an atom.
Note that, when a dynamic name is used, Elixir won&#39;t nest the name under the
current module nor automatically set up an alias.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defoverridable/1">
    <a href="#defoverridable/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defoverridable(keywords)</span>
      
  </div>
  
  <section class="docstring">
    <p>Makes the given functions in the current module overridable.</p>

<p>An overridable function is lazily defined, allowing a developer to override
it.</p>

<h2>Example</h2>

<pre><code class="elixir">defmodule DefaultMod do
  defmacro __using__(_opts) do
    quote do
      def test(x, y) do
        x + y
      end

      defoverridable [test: 2]
    end
  end
end

defmodule InheritMod do
  use DefaultMod

  def test(x, y) do
    x * y + super(x, y)
  end
end
</code></pre>

<p>As seen as in the example above, <code>super</code> can be used to call the default
implementation.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defp/2">
    <a href="#defp/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defp(call, expr \\ nil)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a private function with the given name and body.</p>

<p>Private functions are only accessible from within the module in which they are
defined. Trying to access a private function from outside the module it&#39;s
defined in results in an <code>UndefinedFunctionError</code> exception.</p>

<p>Check <a href="#def/2"><code>def/2</code></a> for more information.</p>

<h2>Examples</h2>

<pre><code class="elixir">defmodule Foo do
  def bar do
    sum(1, 2)
  end

  defp sum(a, b), do: a + b
end

Foo.bar #=&gt; 3
Foo.sum(1, 2) #=&gt; ** (UndefinedFunctionError) undefined function: Foo.sum/2
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defprotocol/2">
    <a href="#defprotocol/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defprotocol(name, list)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a protocol.</p>

<p>A protocol specifies an API that should be defined by its
implementations.</p>

<h2>Examples</h2>

<p>In Elixir, only <code>false</code> and <code>nil</code> are considered falsy values.
Everything else evaluates to <code>true</code> in <code>if</code> clauses. Depending
on the application, it may be important to specify a <code>blank?</code>
protocol that returns a boolean for other data types that should
be considered &quot;blank&quot;. For instance, an empty list or an empty
binary could be considered blank.</p>

<p>Such protocol could be implemented as follows:</p>

<pre><code class="elixir">defprotocol Blank do
  @doc &quot;Returns `true` if `data` is considered blank/empty&quot;
  def blank?(data)
end
</code></pre>

<p>Now that the protocol is defined it can be implemented. It needs to be
implemented for each Elixir type; for example:</p>

<pre><code class="elixir"># Integers are never blank
defimpl Blank, for: Integer do
  def blank?(number), do: false
end

# The only blank list is the empty one
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end

# The only blank atoms are &quot;false&quot; and &quot;nil&quot;
defimpl Blank, for: Atom do
  def blank?(false), do: true
  def blank?(nil),   do: true
  def blank?(_),     do: false
end
</code></pre>

<p>The implementation of the <code>Blank</code> protocol would need to be defined for all
Elixir types. The available types are:</p>

<ul>
<li>Structs (see below)</li>
<li><code>Tuple</code></li>
<li><code>Atom</code></li>
<li><code>List</code></li>
<li><code>BitString</code></li>
<li><code>Integer</code></li>
<li><code>Float</code></li>
<li><code>Function</code></li>
<li><code>PID</code></li>
<li><code>Map</code></li>
<li><code>Port</code></li>
<li><code>Reference</code></li>
<li><code>Any</code> (see below)</li>
</ul>

<h2>Protocols and Structs</h2>

<p>The real benefit of protocols comes when mixed with structs.
For instance, Elixir ships with many data types implemented as
structs, like <code>HashDict</code> and <code>HashSet</code>. We can implement the
<code>Blank</code> protocol for those types as well:</p>

<pre><code class="elixir">defimpl Blank, for: [HashDict, HashSet] do
  def blank?(enum_like), do: Enum.empty?(enum_like)
end
</code></pre>

<p>When implementing a protocol for a struct, the <code>:for</code> option can be omitted if
the <code>defimpl</code> call is inside the module that defines the struct:</p>

<pre><code class="elixir">defmodule User do
  defstruct [:email, :name]

  defimpl Blank do
    def blank?(%User{}), do: false
  end
end
</code></pre>

<p>If a protocol is not found for a given type, it will fallback to
<code>Any</code>.</p>

<h2>Fallback to any</h2>

<p>In some cases, it may be convenient to provide a default
implementation for all types. This can be achieved by
setting the <code>@fallback_to_any</code> attribute to <code>true</code> in the protocol
definition:</p>

<pre><code class="elixir">defprotocol Blank do
  @fallback_to_any true
  def blank?(data)
end
</code></pre>

<p>The <code>Blank</code> protocol can now be implemented for <code>Any</code>:</p>

<pre><code class="elixir">defimpl Blank, for: Any do
  def blank?(_), do: true
end
</code></pre>

<p>One may wonder why such behaviour (fallback to any) is not the default one.</p>

<p>It is two-fold: first, the majority of protocols cannot
implement an action in a generic way for all types; in fact,
providing a default implementation may be harmful, because users
may rely on the default implementation instead of providing a
specialized one.</p>

<p>Second, falling back to <code>Any</code> adds an extra lookup to all types,
which is unnecessary overhead unless an implementation for <code>Any</code> is
required.</p>

<h2>Types</h2>

<p>Defining a protocol automatically defines a type named <code>t</code>, which
can be used as follows:</p>

<pre><code class="elixir">@spec present?(Blank.t) :: boolean
def present?(blank) do
  not Blank.blank?(blank)
end
</code></pre>

<p>The <code>@spec</code> above expresses that all types allowed to implement the
given protocol are valid argument types for the given function.</p>

<h2>Reflection</h2>

<p>Any protocol module contains three extra functions:</p>

<ul>
<li><p><code>__protocol__/1</code> - returns the protocol name when <code>:name</code> is given, and a
keyword list with the protocol functions and their arities when
<code>:functions</code> is given</p></li>
<li><p><code>impl_for/1</code> - receives a structure and returns the module that
implements the protocol for the structure, <code>nil</code> otherwise</p></li>
<li><p><code>impl_for!/1</code> - same as above but raises an error if an implementation is
not found</p>

<pre><code class="elixir">Enumerable.__protocol__(:functions)
#=&gt; [count: 1, member?: 2, reduce: 3]

Enumerable.impl_for([])
#=&gt; Enumerable.List

Enumerable.impl_for(42)
#=&gt; nil
</code></pre></li>
</ul>

<h2>Consolidation</h2>

<p>In order to cope with code loading in development, protocols in
Elixir provide a slow implementation of protocol dispatching specific
to development.</p>

<p>In order to speed up dispatching in production environments, where
all implementations are known up-front, Elixir provides a feature
called protocol consolidation. For this reason, all protocols are
compiled with <code>debug_info</code> set to <code>true</code>, regardless of the option
set by <code>elixirc</code> compiler. The debug info though may be removed
after consolidation.</p>

<p>For more information on how to apply protocol consolidation to
a given project, please check the functions in the <code>Protocol</code>
module or the <code>mix compile.protocols</code> task.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="defstruct/1">
    <a href="#defstruct/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">defstruct(fields)</span>
      
  </div>
  
  <section class="docstring">
    <p>Defines a struct.</p>

<p>A struct is a tagged map that allows developers to provide
default values for keys, tags to be used in polymorphic
dispatches and compile time assertions.</p>

<p>The only thing needed to define a struct is a <code>__struct__/0</code> function that
returns a map with the struct fields and their default values. <a href="#defstruct/1"><code>defstruct/1</code></a>
is a convenience macro which defines such a function (as well as a <code>t</code> type
and deriving conveniences).</p>

<p>When using <a href="#defstruct/1"><code>defstruct/1</code></a>, a struct named like the enclosing module is defined.</p>

<p>For more information about structs, please check <code>Kernel.SpecialForms.%/2</code>.</p>

<h2>Examples</h2>

<pre><code class="elixir">defmodule User do
  defstruct name: nil, age: nil
end
</code></pre>

<p>Struct fields are evaluated at compile-time, which allows
them to be dynamic. In the example below, <code>10 + 11</code> is
evaluated at compile-time and the age field is stored
with value <code>21</code>:</p>

<pre><code class="elixir">defmodule User do
  defstruct name: nil, age: 10 + 11
end
</code></pre>

<p>The <code>fields</code> argument is usually a keyword list with fields as keys and
default values as corresponding values. <a href="#defstruct/1"><code>defstruct/1</code></a> also supports a list of
atoms as its argument: in that case, the atoms in the list will be used as
the struct&#39;s fields and they will all default to <code>nil</code>.</p>

<pre><code class="elixir">defmodule Post do
  defstruct [:title, :content, :author]
end
</code></pre>

<h2>Deriving</h2>

<p>Although structs are maps, by default structs do not implement
any of the protocols implemented for maps. For example, attempting
to use a protocol with the <code>User</code> struct leads to an error:</p>

<pre><code class="elixir">john = %User{name: &quot;John&quot;}
MyProtocol.call(john)
** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}
</code></pre>

<p><a href="#defstruct/1"><code>defstruct/1</code></a>, however, allows protocol implementations to be
<em>derived</em>. This can be done by defining a <code>@derive</code> attribute as a
list before invoking <a href="#defstruct/1"><code>defstruct/1</code></a>:</p>

<pre><code class="elixir">defmodule User do
  @derive [MyProtocol]
  defstruct name: nil, age: 10 + 11
end

MyProtocol.call(john) #=&gt; works
</code></pre>

<p>For each protocol in the <code>@derive</code> list, Elixir will assert there is an
implementation of that protocol for any (regardless if fallback to any
is <code>true</code>) and check if the any implementation defines a <code>__deriving__/3</code>
callback. If so, the callback is invoked, otherwise an implementation
that simply points to the any implementation is automatically derived.</p>

<h2>Types</h2>

<p>It is recommended to define types for structs. By convention such type
is called <code>t</code>. To define a struct inside a type, the struct literal syntax
is used:</p>

<pre><code class="elixir">defmodule User do
  defstruct name: &quot;John&quot;, age: 25
  @type t :: %User{name: String.t, age: non_neg_integer}
end
</code></pre>

<p>It is recommended to only use the struct syntax when defining the struct&#39;s
type. When referring to another struct it&#39;s better to use <code>User.t</code>instead of
<code>%User{}</code>.</p>

<p>The types of the struct fields that are not included in the struct&#39;s type
default to <code>term</code>.</p>

<p>Structs whose internal structure is private to the local module (pattern
matching them or directly accessing their fields should not be allowed) should
use the <code>@opaque</code> attribute. Structs whose internal structure is public should
use <code>@type</code>. See <code>Kernel.Typespec</code> for more information on opaque types.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="destructure/2">
    <a href="#destructure/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">destructure(left, right)</span>
      
  </div>
  
  <section class="docstring">
    <p>Destructures two lists, assigning each term in the
right one to the matching term in the left one.</p>

<p>Unlike pattern matching via <code>=</code>, if the sizes of the left
and right lists don&#39;t match, destructuring simply stops
instead of raising an error.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; destructure([x, y, z], [1, 2, 3, 4, 5])
iex&gt; {x, y, z}
{1, 2, 3}
</code></pre>

<p>In the example above, even though the right list has more entries than the
left one, destructuring works fine. If the right list is smaller, the
remaining items are simply set to <code>nil</code>:</p>

<pre><code class="iex elixir">iex&gt; destructure([x, y, z], [1])
iex&gt; {x, y, z}
{1, nil, nil}
</code></pre>

<p>The left-hand side supports any expression you would use
on the left-hand side of a match:</p>

<pre><code class="elixir">x = 1
destructure([^x, y, z], [1, 2, 3])
</code></pre>

<p>The example above will only work if <code>x</code> matches the first value in the right
list. Otherwise, it will raise a <code>MatchError</code> (like the <code>=</code> operator would
do).</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="get_and_update_in/2">
    <a href="#get_and_update_in/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">get_and_update_in(path, fun)</span>
      
  </div>
  
  <section class="docstring">
    <p>Gets a value and updates a nested data structure via the given <code>path</code>.</p>

<p>This is similar to <a href="#get_and_update_in/3"><code>get_and_update_in/3</code></a>, except the path is extracted
via a macro rather than passing a list. For example:</p>

<pre><code class="elixir">get_and_update_in(opts[:foo][:bar], &amp;{&amp;1, &amp;1 + 1})
</code></pre>

<p>Is equivalent to:</p>

<pre><code class="elixir">get_and_update_in(opts, [:foo, :bar], &amp;{&amp;1, &amp;1 + 1})
</code></pre>

<p>Note that in order for this macro to work, the complete path must always
be visible by this macro. See the Paths section below.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; get_and_update_in(users[&quot;john&quot;].age, &amp;{&amp;1, &amp;1 + 1})
{27, %{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}}
</code></pre>

<h2>Paths</h2>

<p>A path may start with a variable, local or remote call, and must be
followed by one or more:</p>

<ul>
<li><p><code>foo[bar]</code> - access a field; in case an intermediate field is not
present or returns <code>nil</code>, an empty map is used</p></li>
<li><p><code>foo.bar</code> - access a map/struct field; in case the field is not
present, an error is raised</p></li>
</ul>

<p>Here are some valid paths:</p>

<pre><code class="elixir">users[&quot;john&quot;][:age]
users[&quot;john&quot;].age
User.all[&quot;john&quot;].age
all_users()[&quot;john&quot;].age
</code></pre>

<p>Here are some invalid ones:</p>

<pre><code class="elixir"># Does a remote call after the initial value
users[&quot;john&quot;].do_something(arg1, arg2)

# Does not access any field
users
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="if/2">
    <a href="#if/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">if(condition, clauses)</span>
      
  </div>
  
  <section class="docstring">
    <p>Provides an <code>if</code> macro.</p>

<p>This macro expects the first argument to be a condition and the second
argument to be a keyword list.</p>

<h2>One-liner examples</h2>

<pre><code class="elixir">if(foo, do: bar)
</code></pre>

<p>In the example above, <code>bar</code> will be returned if <code>foo</code> evaluates to
<code>true</code> (i.e., it is neither <code>false</code> nor <code>nil</code>). Otherwise, <code>nil</code> will be
returned.</p>

<p>An <code>else</code> option can be given to specify the opposite:</p>

<pre><code class="elixir">if(foo, do: bar, else: baz)
</code></pre>

<h2>Blocks examples</h2>

<p>It&#39;s also possible to pass a block to the <code>if</code> macro. The first
example above would be translated to:</p>

<pre><code class="elixir">if foo do
  bar
end
</code></pre>

<p>Note that <code>do/end</code> become delimiters. The second example would
translate to:</p>

<pre><code class="elixir">if foo do
  bar
else
  baz
end
</code></pre>

<p>In order to compare more than two clauses, the <code>cond/1</code> macro has to be used.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="in/2">
    <a href="#in/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left in right</span>
      
  </div>
  
  <section class="docstring">
    <p>Checks if the element on the left-hand side is a member of the
collection on the right-hand side.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; x in [1, 2, 3]
true
</code></pre>

<p>This operator (which is a macro) simply translates to a call to
<code>Enum.member?/2</code>. The example above would translate to:</p>

<pre><code class="elixir">Enum.member?([1, 2, 3], x)
</code></pre>

<h2>Guards</h2>

<p>The <code>in</code> operator can be used in guard clauses as long as the
right-hand side is a range or a list. In such cases, Elixir will expand the
operator to a valid guard expression. For example:</p>

<pre><code class="elixir">when x in [1, 2, 3]
</code></pre>

<p>translates to:</p>

<pre><code class="elixir">when x === 1 or x === 2 or x === 3
</code></pre>

<p>When using ranges:</p>

<pre><code class="elixir">when x in 1..3
</code></pre>

<p>translates to:</p>

<pre><code class="elixir">when x &gt;= 1 and x &lt;= 3
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="is_nil/1">
    <a href="#is_nil/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">is_nil(term)</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>term</code> is <code>nil</code>, <code>false</code> otherwise.</p>

<p>Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; is_nil(1)
false

iex&gt; is_nil(nil)
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="match?/2">
    <a href="#match?/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">match?(pattern, expr)</span>
      
  </div>
  
  <section class="docstring">
    <p>A convenience macro that checks if the right side (an expression) matches the
left side (a pattern).</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; match?(1, 1)
true

iex&gt; match?(1, 2)
false

iex&gt; match?({1, _}, {1, 2})
true

iex&gt; map = %{a: 1, b: 2}
iex&gt; match?(%{a: _}, map)
true

iex&gt; a = 1
iex&gt; match?(^a, 1)
true
</code></pre>

<p><a href="#match?/2"><code>match?/2</code></a> is very useful when filtering of finding a value in an enumerable:</p>

<pre><code class="elixir">list = [{:a, 1}, {:b, 2}, {:a, 3}]
Enum.filter list, &amp;match?({:a, _}, &amp;1)
#=&gt; [{:a, 1}, {:a, 3}]
</code></pre>

<p>Guard clauses can also be given to the match:</p>

<pre><code class="elixir">list = [{:a, 1}, {:b, 2}, {:a, 3}]
Enum.filter list, &amp;match?({:a, x} when x &lt; 2, &amp;1)
#=&gt; [{:a, 1}]
</code></pre>

<p>However, variables assigned in the match will not be available
outside of the function call (unlike regular pattern matching with the <code>=</code>
operator):</p>

<pre><code class="iex elixir">iex&gt; match?(_x, 1)
true
iex&gt; binding()
[]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="or/2">
    <a href="#or/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left or right</span>
      
  </div>
  
  <section class="docstring">
    <p>Boolean or.</p>

<p>If the first argument is <code>true</code>, <code>true</code> is returned; otherwise, the second
argument is returned.</p>

<p>Requires only the first argument to be a boolean since it short-circuits.
If the first argument is not a boolean, an <code>ArgumentError</code> exception is
raised.</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; true or false
true
iex&gt; false or 42
42
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="put_in/2">
    <a href="#put_in/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">put_in(path, value)</span>
      
  </div>
  
  <section class="docstring">
    <p>Puts a value in a nested structure via the given <code>path</code>.</p>

<p>This is similar to <a href="#put_in/3"><code>put_in/3</code></a>, except the path is extracted via
a macro rather than passing a list. For example:</p>

<pre><code class="elixir">put_in(opts[:foo][:bar], :baz)
</code></pre>

<p>Is equivalent to:</p>

<pre><code class="elixir">put_in(opts, [:foo, :bar], :baz)
</code></pre>

<p>Note that in order for this macro to work, the complete path must always
be visible by this macro. For more information about the supported path
expressions, please check <a href="#get_and_update_in/2"><code>get_and_update_in/2</code></a> docs.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; put_in(users[&quot;john&quot;][:age], 28)
%{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}

iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; put_in(users[&quot;john&quot;].age, 28)
%{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="raise/1">
    <a href="#raise/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">raise(msg)</span>
      
  </div>
  
  <section class="docstring">
    <p>Raises an exception.</p>

<p>If the argument <code>msg</code> is a binary, it raises a <code>RuntimeError</code> exception
using the given argument as message.</p>

<p>If <code>msg</code> is an atom, it just calls <a href="#raise/2"><code>raise/2</code></a> with the atom as the first
argument and <code>[]</code> as the second argument.</p>

<p>If <code>msg</code> is anything else, raises an <code>ArgumentError</code> exception.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; raise &quot;oops&quot;
** (RuntimeError) oops

try do
  1 + :foo
rescue
  x in [ArithmeticError] -&gt;
    IO.puts &quot;that was expected&quot;
    raise x
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="raise/2">
    <a href="#raise/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">raise(exception, attrs)</span>
      
  </div>
  
  <section class="docstring">
    <p>Raises an exception.</p>

<p>Calls the <code>exception/1</code> function on the given argument (which has to be a
module name like <code>ArgumentError</code> or <code>RuntimeError</code>) passing <code>attrs</code> as the
attributes in order to retrieve the exception struct.</p>

<p>Any module that contains a call to the <a href="#defexception/1"><code>defexception/1</code></a> macro automatically
implements the <code>exception/1</code> callback expected by <a href="#raise/2"><code>raise/2</code></a>. See the docs for
<a href="#defexception/1"><code>defexception/1</code></a> for more information.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; raise(ArgumentError, message: &quot;Sample&quot;)
** (ArgumentError) Sample
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="reraise/2">
    <a href="#reraise/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">reraise(msg, stacktrace)</span>
      
  </div>
  
  <section class="docstring">
    <p>Raises an exception preserving a previous stacktrace.</p>

<p>Works like <a href="#raise/1"><code>raise/1</code></a> but does not generate a new stacktrace.</p>

<p>Notice that <code>System.stacktrace/0</code> returns the stacktrace
of the last exception. That said, it is common to assign
the stacktrace as the first expression inside a <code>rescue</code>
clause as any other exception potentially raised (and
rescued) between the rescue clause and the raise call
may change the <code>System.stacktrace/0</code> value.</p>

<h2>Examples</h2>

<pre><code class="elixir">try do
  raise &quot;oops&quot;
rescue
  exception -&gt;
    stacktrace = System.stacktrace
    if Exception.message(exception) == &quot;oops&quot; do
      reraise exception, stacktrace
    end
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="reraise/3">
    <a href="#reraise/3" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">reraise(exception, attrs, stacktrace)</span>
      
  </div>
  
  <section class="docstring">
    <p>Raises an exception preserving a previous stacktrace.</p>

<p><a href="#reraise/3"><code>reraise/3</code></a> works like <a href="#reraise/2"><code>reraise/2</code></a>, except it passes arguments to the
<code>exception/1</code> function like explained in <a href="#raise/2"><code>raise/2</code></a>.</p>

<h2>Examples</h2>

<pre><code class="elixir">try do
  raise &quot;oops&quot;
rescue
  exception -&gt;
    stacktrace = System.stacktrace
    reraise WrapperError, [exception: exception], stacktrace
end
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_C/2">
    <a href="#sigil_C/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_C(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~C</code>.</p>

<p>It simply returns a char list without escaping characters and without
interpolations.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; ~C(foo)
&#39;foo&#39;

iex&gt; ~C(f#{o}o)
&#39;f\#{o}o&#39;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_R/2">
    <a href="#sigil_R/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_R(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~R</code>.</p>

<p>It returns a regular expression pattern without escaping
nor interpreting interpolations.</p>

<p>More information on regexes can be found in the <code>Regex</code> module.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; Regex.match?(~R(f#{1,3}o), &quot;f#o&quot;)
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_S/2">
    <a href="#sigil_S/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_S(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~S</code>.</p>

<p>It simply returns a string without escaping characters and without
interpolations.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; ~S(foo)
&quot;foo&quot;

iex&gt; ~S(f#{o}o)
&quot;f\#{o}o&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_W/2">
    <a href="#sigil_W/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_W(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~W</code>.</p>

<p>It returns a list of &quot;words&quot; split by whitespace without escaping nor
interpreting interpolations.</p>

<h2>Modifiers</h2>

<ul>
<li><code>s</code>: words in the list are strings (default)</li>
<li><code>a</code>: words in the list are atoms</li>
<li><code>c</code>: words in the list are char lists</li>
</ul>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; ~W(foo #{bar} baz)
[&quot;foo&quot;, &quot;\#{bar}&quot;, &quot;baz&quot;]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_c/2">
    <a href="#sigil_c/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_c(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~c</code>.</p>

<p>It returns a char list as if it were a single quoted string, unescaping
characters and replacing interpolations.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; ~c(foo)
&#39;foo&#39;

iex&gt; ~c(f#{:o}o)
&#39;foo&#39;

iex&gt; ~c(f\#{:o}o)
&#39;f\#{:o}o&#39;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_r/2">
    <a href="#sigil_r/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_r(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~r</code>.</p>

<p>It returns a regular expression pattern, unescaping characters and replacing
interpolations.</p>

<p>More information on regexes can be found in the <code>Regex</code> module.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; Regex.match?(~r(foo), &quot;foo&quot;)
true

iex&gt; Regex.match?(~r/abc/, &quot;abc&quot;)
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_s/2">
    <a href="#sigil_s/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_s(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~s</code>.</p>

<p>It returns a string as if it was a double quoted string, unescaping characters
and replacing interpolations.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; ~s(foo)
&quot;foo&quot;

iex&gt; ~s(f#{:o}o)
&quot;foo&quot;

iex&gt; ~s(f\#{:o}o)
&quot;f\#{:o}o&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="sigil_w/2">
    <a href="#sigil_w/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">sigil_w(term, modifiers)</span>
      
  </div>
  
  <section class="docstring">
    <p>Handles the sigil <code>~w</code>.</p>

<p>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and
interpolation happens for each word.</p>

<h2>Modifiers</h2>

<ul>
<li><code>s</code>: words in the list are strings (default)</li>
<li><code>a</code>: words in the list are atoms</li>
<li><code>c</code>: words in the list are char lists</li>
</ul>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; ~w(foo #{:bar} baz)
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]

iex&gt; ~w(--source test/enum_test.exs)
[&quot;--source&quot;, &quot;test/enum_test.exs&quot;]

iex&gt; ~w(foo bar baz)a
[:foo, :bar, :baz]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_char_list/1">
    <a href="#to_char_list/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_char_list(arg)</span>
      
  </div>
  
  <section class="docstring">
    <p>Converts the argument to a char list according to the <code>List.Chars</code> protocol.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; to_char_list(:foo)
&#39;foo&#39;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_string/1">
    <a href="#to_string/1" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_string(arg)</span>
      
  </div>
  
  <section class="docstring">
    <p>Converts the argument to a string according to the
<code>String.Chars</code> protocol.</p>

<p>This is the function invoked when there is string interpolation.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; to_string(:foo)
&quot;foo&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="unless/2">
    <a href="#unless/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">unless(condition, clauses)</span>
      
  </div>
  
  <section class="docstring">
    <p>Provides an <code>unless</code> macro.</p>

<p>This macro evaluates and returns the <code>do</code> block passed in as the second
argument unless <code>clause</code> evaluates to <code>true</code>. Otherwise, it returns the value
of the <code>else</code> block if present or <code>nil</code> if not.</p>

<p>See also <a href="#if/2"><code>if/2</code></a>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; unless(Enum.empty?([]), do: &quot;Hello&quot;)
nil

iex&gt; unless(Enum.empty?([1, 2, 3]), do: &quot;Hello&quot;)
&quot;Hello&quot;

iex&gt; unless Enum.sum([2, 2]) == 5 do
...&gt;   &quot;Math still works&quot;
...&gt; else
...&gt;   &quot;Math is broken&quot;
...&gt; end
&quot;Math still works&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="update_in/2">
    <a href="#update_in/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">update_in(path, fun)</span>
      
  </div>
  
  <section class="docstring">
    <p>Updates a nested structure via the given <code>path</code>.</p>

<p>This is similar to <a href="#update_in/3"><code>update_in/3</code></a>, except the path is extracted via
a macro rather than passing a list. For example:</p>

<pre><code class="elixir">update_in(opts[:foo][:bar], &amp;(&amp;1 + 1))
</code></pre>

<p>Is equivalent to:</p>

<pre><code class="elixir">update_in(opts, [:foo, :bar], &amp;(&amp;1 + 1))
</code></pre>

<p>Note that in order for this macro to work, the complete path must always
be visible by this macro. For more information about the supported path
expressions, please check <a href="#get_and_update_in/2"><code>get_and_update_in/2</code></a> docs.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; update_in(users[&quot;john&quot;][:age], &amp;(&amp;1 + 1))
%{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}

iex&gt; users = %{&quot;john&quot; =&gt; %{age: 27}, &quot;meg&quot; =&gt; %{age: 23}}
iex&gt; update_in(users[&quot;john&quot;].age, &amp;(&amp;1 + 1))
%{&quot;john&quot; =&gt; %{age: 28}, &quot;meg&quot; =&gt; %{age: 23}}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="use/2">
    <a href="#use/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">use(module, opts \\ [])</span>
      
  </div>
  
  <section class="docstring">
    <p>Uses the given module in the current context.</p>

<h2>Examples</h2>

<p>For example, in order to write tests using the ExUnit framework,
a developer should use the <code>ExUnit.Case</code> module:</p>

<pre><code class="elixir">defmodule AssertionTest do
  use ExUnit.Case, async: true

  test &quot;always pass&quot; do
    assert true
  end
end
</code></pre>

<p>By calling <code>use</code>, a hook called <code>__using__</code> will be invoked in
<code>ExUnit.Case</code> which will then do the proper setup.</p>

<p>Simply put, <code>use</code> translates to:</p>

<pre><code class="elixir">defmodule AssertionTest do
  require ExUnit.Case
  ExUnit.Case.__using__([async: true])

  test &quot;always pass&quot; do
    assert true
  end
end
</code></pre>

<p>Where <code>__using__/1</code> is just a regular macro that can be defined
in any module:</p>

<pre><code class="elixir">defmodule MyModule do
  defmacro __using__(opts) do
    quote do
      # code that will run in the module that uses MyModule
    end
  end
end
</code></pre>

<h2>Best practices</h2>

<p><code>__using__</code> is typically used when there is a need to set some state
(via module attributes) or callbacks (like <code>@before_compile</code>)
into the caller.</p>

<p><code>__using__</code> may also be used to alias, require or import functionality
from different modules:</p>

<pre><code class="elixir">defmodule MyModule do
  defmacro __using__(opts) do
    quote do
      import MyModule.Foo
      import MyModule.Bar
      import MyModule.Baz

      alias MyModule.Repo
    end
  end
end
</code></pre>

<p>However, do not provide <code>__using__</code> if all it does is to import,
alias or require the module itself. For example, do not:</p>

<pre><code class="elixir">defmodule MyModule do
  defmacro __using__(opts) do
    quote do
      import MyModule
    end
  end
end
</code></pre>

<p>In such cases, developers must just import or alias the module
directly, allowing developers to customize those as they wish,
without the indirection behind <code>use</code>.</p>

<p>Finally, developers should also avoid defining functions inside
the <code>__using__</code> callback, unless those functions are the default
implementation of a previously defined <code>@callback</code>. In case you
want to provide some existing functionality to the user module,
please define it a module which will be imported accordingly.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="var!/2">
    <a href="#var!/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">var!(var, context \\ nil)</span>
      
  </div>
  
  <section class="docstring">
    <p>When used inside quoting, marks that the given variable should
not be hygienized.</p>

<p>The argument can be either a variable unquoted or in standard tuple form
<code>{name, meta, context}</code>.</p>

<p>Check <a href="Kernel.SpecialForms.html#quote/2"><code>Kernel.SpecialForms.quote/2</code></a> for more information.</p>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="|&gt;/2">
    <a href="#|&gt;/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left |&gt; right</span>
      
  </div>
  
  <section class="docstring">
    <p>Pipe operator.</p>

<p>This operator introduces the expression on the left-hand side as
the first argument to the function call on the right-hand side.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; [1, [2], 3] |&gt; List.flatten()
[1, 2, 3]
</code></pre>

<p>The example above is the same as calling <code>List.flatten([1, [2], 3])</code>.</p>

<p>The <code>|&gt;</code> operator is mostly useful when there is a desire to execute a series
of operations resembling a pipeline:</p>

<pre><code class="iex elixir">iex&gt; [1, [2], 3] |&gt; List.flatten |&gt; Enum.map(fn x -&gt; x * 2 end)
[2, 4, 6]
</code></pre>

<p>In the example above, the list <code>[1, [2], 3]</code> is passed as the first argument
to the <code>List.flatten/1</code> function, then the flattened list is passed as the
first argument to the <code>Enum.map/2</code> function which doubles each element of the
list.</p>

<p>In other words, the expression above simply translates to:</p>

<pre><code class="elixir">Enum.map(List.flatten([1, [2], 3]), fn x -&gt; x * 2 end)
</code></pre>

<p>Beware of operator precedence when using the pipe operator.
For example, the following expression:</p>

<pre><code class="elixir">String.graphemes &quot;Hello&quot; |&gt; Enum.reverse
</code></pre>

<p>Translates to:</p>

<pre><code class="elixir">String.graphemes(&quot;Hello&quot; |&gt; Enum.reverse)
</code></pre>

<p>which results in an error as the <code>Enumerable</code> protocol is not defined
for binaries. Adding explicit parentheses resolves the ambiguity:</p>

<pre><code class="elixir">String.graphemes(&quot;Hello&quot;) |&gt; Enum.reverse
</code></pre>

<p>Or, even better:</p>

<pre><code class="elixir">&quot;Hello&quot; |&gt; String.graphemes |&gt; Enum.reverse
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="||/2">
    <a href="#||/2" class="detail-link" title="Link to this macro">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">left || right</span>
      
  </div>
  
  <section class="docstring">
    <p>Provides a short-circuit operator that evaluates and returns the second
expression only if the first one does not evaluate to <code>true</code> (i.e., it
is either <code>nil</code> or <code>false</code>). Returns the first expression otherwise.</p>

<p>Not allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; Enum.empty?([1]) || Enum.empty?([1])
false

iex&gt; List.first([]) || true
true

iex&gt; Enum.empty?([1]) || 1
1

iex&gt; Enum.empty?([]) || throw(:bad)
true
</code></pre>

<p>Note that, unlike Erlang&#39;s <code>or</code> operator,
this operator accepts any expression as the first argument,
not only booleans.</p>

  </section>
</div>

        </section>
      

      
        <footer class="footer">
      <p>
        Designed by
        <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>
        and the
        <a href="https://github.com/elixir-lang/ex_doc/graphs/contributors" target="_blank">ExDoc team</a>.
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.9.1-dev).
      </p>
    </footer>
  </div>
</section>
</div>
    <script src="dist/app.js"></script>
  </body>
</html>

