    <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <title>String – Elixir v1.0.1</title>
      
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.9.1-dev">
    <link href="http://fonts.googleapis.com/css?family=Lato:400,300,700,900|Merriweather:300italic,300,700,700italic|Inconsolata:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="dist/app.css" />
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body>

    
    <div class="main">
<button class="sidebar-toggle">
  <i class="fa fa-bars"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="fa fa-bars"></i>
  </button>

  
    <div class="sidebar-projectDetails sidebar-projectLink">
      <h1 class="sidebar-projectName">
        Elixir
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.0.1
      </h2>
    </div>
    
      <img src="assets/logo.png" alt="Elixir" class="sidebar-projectImage">
    
  

  <div class="sidebar-search">
    <i class="fa fa-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" results="0" />
  </div>

  <ul class="sidebar-mainNav">
    
      <li><a href="README.html">README</a></li>
    

    <li><a href="overview.html">Overview</a></li>
  </ul>

  <ul class="sidebar-listNav">
    
      <li><a id="modules_list" href="#full_list">Modules</a></li>
    

    
      <li><a id="exceptions_list" href="#full_list">Exceptions</a></li>
    

    
      <li><a id="protocols_list" href="#full_list">Protocols</a></li>
    
  </ul>

  <ul id="full_list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section id="content" class="content">
  <div class="content-inner">


      <h1>
        String
        
        
      </h1>

      
        <section id="moduledoc" class="docstring">
          <p>A String in Elixir is a UTF-8 encoded binary.</p>

<h2>Codepoints and graphemes</h2>

<p>The functions in this module act according to the Unicode
Standard, version 6.3.0. As per the standard, a codepoint is
a Unicode Character, which may be represented by one or more
bytes. For example, the character &quot;é&quot; is represented with two
bytes:</p>

<pre><code class="iex elixir">iex&gt; byte_size(&quot;é&quot;)
2
</code></pre>

<p>However, this module returns the proper length:</p>

<pre><code class="iex elixir">iex&gt; String.length(&quot;é&quot;)
1
</code></pre>

<p>Furthermore, this module also presents the concept of
graphemes, which are multiple characters that may be
&quot;perceived as a single character&quot; by readers. For example,
the same &quot;é&quot; character written above could be represented
by the letter &quot;e&quot; followed by the accent ́:</p>

<pre><code class="iex elixir">iex&gt; string = &quot;\u0065\u0301&quot;
iex&gt; byte_size(string)
3
iex&gt; String.length(string)
1
</code></pre>

<p>Although the example above is made of two characters, it is
perceived by users as one.</p>

<p>Graphemes can also be two characters that are interpreted
as one by some languages. For example, some languages may
consider &quot;ch&quot; as a grapheme. However, since this information
depends on the locale, it is not taken into account by this
module.</p>

<p>In general, the functions in this module rely on the Unicode
Standard, but do not contain any of the locale specific behaviour.</p>

<p>More information about graphemes can be found in the <a href="http://www.unicode.org/reports/tr29/">Unicode
Standard Annex #29</a>.
This current Elixir version implements Extended Grapheme Cluster
algorithm.</p>

<h2>String and binary operations</h2>

<p>To act accordingly to the Unicode Standard, many functions
in this module runs in linear time, as it needs to traverse
the whole string considering the proper Unicode codepoints.</p>

<p>For example, <a href="String.html#length/1"><code>String.length/1</code></a> is going to take longer as
the input grows. On the other hand, <a href="Kernel.html#byte_size/1"><code>Kernel.byte_size/1</code></a> always runs
in constant time (i.e. regardless of the input size).</p>

<p>This means often there are performance costs in using the
functions in this module, compared to the more low-level
operations that work directly with binaries:</p>

<ul>
<li><a href="Kernel.html#binary_part/3"><code>Kernel.binary_part/3</code></a> - retrieves part of the binary</li>
<li><a href="Kernel.html#bit_size/1"><code>Kernel.bit_size/1</code></a> and <a href="Kernel.html#byte_size/1"><code>Kernel.byte_size/1</code></a> - size related functions</li>
<li><a href="Kernel.html#is_bitstring/1"><code>Kernel.is_bitstring/1</code></a> and <a href="Kernel.html#is_binary/1"><code>Kernel.is_binary/1</code></a> - type checking function</li>
<li>Plus a number of functions for working with binaries (bytes)
in the <a href="http://www.erlang.org/doc/man/binary.html"><code>:binary</code> module</a></li>
</ul>

<p>There are many situations where using the <a href="String.html#content"><code>String</code></a> module can
be avoided in favor of binary functions or pattern matching.
For example, imagine you have a string <code>prefix</code> and you want to
remove this prefix from another string named <code>full</code>.</p>

<p>One may be tempted to write:</p>

<pre><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = String.length(prefix)
...&gt;   String.slice(full, base, String.length(full) - base)
...&gt; end
iex&gt; take_prefix.(&quot;Mr. John&quot;, &quot;Mr. &quot;)
&quot;John&quot;
</code></pre>

<p>Although the function above works, it performs poorly. To
calculate the length of the string, we need to traverse it
fully, so we traverse both <code>prefix</code> and <code>full</code> strings, then
slice the <code>full</code> one, traversing it again.</p>

<p>A first attempting at improving it could be with ranges:</p>

<pre><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = String.length(prefix)
...&gt;   String.slice(full, base..-1)
...&gt; end
iex&gt; take_prefix.(&quot;Mr. John&quot;, &quot;Mr. &quot;)
&quot;John&quot;
</code></pre>

<p>While this is much better (we don&#39;t traverse <code>full</code> twice),
it could still be improved. In this case, since we want to
extract a substring from a string, we can use <code>byte_size/1</code>
and <code>binary_part/3</code> as there is no chance we will slice in
the middle of a codepoint made of more than one byte:</p>

<pre><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = byte_size(prefix)
...&gt;   binary_part(full, base, byte_size(full) - base)
...&gt; end
iex&gt; take_prefix.(&quot;Mr. John&quot;, &quot;Mr. &quot;)
&quot;John&quot;
</code></pre>

<p>Or simply use pattern matching:</p>

<pre><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = byte_size(prefix)
...&gt;   &lt;&lt;_ :: binary-size(base), rest :: binary&gt;&gt; = full
...&gt;   rest
...&gt; end
iex&gt; take_prefix.(&quot;Mr. John&quot;, &quot;Mr. &quot;)
&quot;John&quot;
</code></pre>

<p>On the other hand, if you want to dynamically slice a string
based on an integer value, then using <a href="String.html#slice/3"><code>String.slice/3</code></a> is the
best option as it guarantees we won&#39;t incorrectly split a valid
codepoint in multiple bytes.</p>

<h2>Integer codepoints</h2>

<p>Although codepoints could be represented as integers, this
module represents all codepoints as strings. For example:</p>

<pre><code class="iex elixir">iex&gt; String.codepoints(&quot;olá&quot;)
[&quot;o&quot;, &quot;l&quot;, &quot;á&quot;]
</code></pre>

<p>There are a couple of ways to retrieve a character integer
codepoint. One may use the <code>?</code> construct:</p>

<pre><code class="iex elixir">iex&gt; ?o
111

iex&gt; ?á
225
</code></pre>

<p>Or also via pattern matching:</p>

<pre><code class="iex elixir">iex&gt; &lt;&lt; eacute :: utf8 &gt;&gt; = &quot;á&quot;
iex&gt; eacute
225
</code></pre>

<p>As we have seen above, codepoints can be inserted into
a string by their hexadecimal code:</p>

<pre><code class="elixir">&quot;ol\u0061\u0301&quot; #=&gt;
&quot;olá&quot;
</code></pre>

<h2>Self-synchronization</h2>

<p>The UTF-8 encoding is self-synchronizing. This means that
if malformed data (i.e., data that is not possible according
to the definition of the encoding) is encountered, only one
codepoint needs to be rejected.</p>

<p>This module relies on this behaviour to ignore such invalid
characters. For example, <a href="#length/1"><code>length/1</code></a> is going to return
a correct result even if an invalid codepoint is fed into it.</p>

<p>In other words, this module expects invalid data to be detected
when retrieving data from the external source. For example, a
driver that reads strings from a database will be the one
responsible to check the validity of the encoding.</p>

<h2>Patterns</h2>

<p>Many functions in this module work with patterns. For example,
String.split/2 can split a string into multiple patterns given
a pattern. This pattern can be a string, a list of strings or
a compiled pattern:</p>

<pre><code class="iex elixir">iex&gt; String.split(&quot;foo bar&quot;, &quot; &quot;)
[&quot;foo&quot;, &quot;bar&quot;]

iex&gt; String.split(&quot;foo bar!&quot;, [&quot; &quot;, &quot;!&quot;])
[&quot;foo&quot;, &quot;bar&quot;, &quot;&quot;]

iex&gt; pattern = :binary.compile_pattern([&quot; &quot;, &quot;!&quot;])
iex&gt; String.split(&quot;foo bar!&quot;, pattern)
[&quot;foo&quot;, &quot;bar&quot;, &quot;&quot;]
</code></pre>

<p>The compiled pattern is useful when the same match will
be done over and over again. Note though the compiled
pattern cannot be stored in a module attribute as the pattern
is generated at runtime and does not survive compile term.</p>

        </section>
      

      
        <section id="summary_details" class="details-list">
          <h1 id="summary" class="section-heading">Summary</h1>
          
  <div class="summary-types summary">
    <h2>
      <a href="#types_details">Types</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#codepoint/0">codepoint()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#grapheme/0">grapheme()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#pattern/0">pattern()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t/0">t()</a>
  </div>
  
</div>

  </div>


          
  <div class="summary-functions summary">
    <h2>
      <a href="#functions_details">Functions</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#printable?/1">printable?(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks if a string is printable considering it is encoded
as UTF-8. Returns <code>true</code> if so, <code>false</code> otherwise</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#valid?/1">valid?(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks whether <code>str</code> contains only valid characters</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#valid_character?/1">valid_character?(codepoint)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks whether <code>string</code> is a valid character</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_char_list/1">to_char_list(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts a string into a char list</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_atom/1">to_atom(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts a string to an atom</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_existing_atom/1">to_existing_atom(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts a string to an existing atom</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#downcase/1">downcase(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts all characters in the given string to lowercase</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#upcase/1">upcase(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts all characters in the given string to uppercase</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#capitalize/1">capitalize(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Converts the first character in the given string to
uppercase and the remainder to lowercase</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/1">split(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Divides a string into substrings at each Unicode whitespace
occurrence with leading and trailing whitespace ignored</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#graphemes/1">graphemes(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns Unicode graphemes in the string as per Extended Grapheme
Cluster algorithm outlined in the <a href="http://www.unicode.org/reports/tr29/">Unicode Standard Annex #29,
Unicode Text Segmentation</a></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_float/1">to_float(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a float whose text representation is <code>string</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#lstrip/1">lstrip(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a string where all leading Unicode whitespaces
has been removed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#strip/1">strip(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a string where all leading and trailing Unicode whitespaces
has been removed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#rstrip/1">rstrip(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a string where all trailing Unicode whitespaces
has been removed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#codepoints/1">codepoints(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns all codepoints in the string</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_integer/1">to_integer(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns an integer whose text representation is <code>string</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#first/1">first(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the first grapheme from a utf8 string,
<code>nil</code> if the string is empty</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#last/1">last(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the last grapheme from a utf8 string,
<code>nil</code> if the string is empty</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#next_codepoint/1">next_codepoint(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the next codepoint in a String</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#next_grapheme/1">next_grapheme(binary)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the next grapheme in a string</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#length/1">length(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the number of Unicode graphemes in a utf8 string</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#next_grapheme_size/1">next_grapheme_size(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the size of the next grapheme</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#reverse/1">reverse(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Reverses the given string. Works on graphemes</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#contains?/2">contains?(string, contents)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks if <code>string</code> contains any of the given <code>contents</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match?/2">match?(string, regex)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks if <code>string</code> matches the given regular expression</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#ends_with?/2">ends_with?(string, suffixes)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>string</code> ends with any of the suffixes given, otherwise
returns <code>false</code>. <code>suffixes</code> can be either a single suffix or a list of suffixes</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#starts_with?/2">starts_with?(string, prefix)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns <code>true</code> if <code>string</code> starts with any of the prefixes given, otherwise
returns <code>false</code>. <code>prefixes</code> can be either a single prefix or a list of prefixes</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#duplicate/2">duplicate(subject, n)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a binary <code>subject</code> duplicated <code>n</code> times</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#jaro_distance/2">jaro_distance(str1, str2)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a float value between 0 (equates to no similarity) and 1 (is an exact match)
representing <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro</a>
distance between <code>str1</code> and <code>str2</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#lstrip/2">lstrip(string, char)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a string where all leading <code>char</code>s have been removed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#strip/2">strip(string, char)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a string where all leading and trailing <code>char</code>s have been
removed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#rstrip/2">rstrip(string, char)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a string where all trailing <code>char</code>s have been removed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#slice/2">slice(string, range)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a substring from the offset given by the start of the
range to the offset given by the end of the range</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_integer/2">to_integer(string, base)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns an integer whose text representation is <code>string</code> in base <code>base</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#at/2">at(string, position)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the grapheme in the <code>position</code> of the given utf8 <code>string</code>.
If <code>position</code> is greater than <code>string</code> length, then it returns <code>nil</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split_at/2">split_at(string, position)</a>
  </div>
  
    <div class="summary-synopsis"><p>Splits a string into two at the specified offset. When the offset given is
negative, location is counted from the end of the string</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#chunk/2">chunk(string, trait)</a>
  </div>
  
    <div class="summary-synopsis"><p>Splits the string into chunks of characters that share a common trait</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/3">split(string, pattern, options \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Divides a string into substrings based on a pattern</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#ljust/3">ljust(subject, len, pad \\ 32)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a new string of length <code>len</code> with <code>subject</code> left justified and padded
with <code>padding</code>. If <code>padding</code> is not present, it defaults to whitespace. When
<code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is returned</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#rjust/3">rjust(subject, len, pad \\ 32)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a new string of length <code>len</code> with <code>subject</code> right justified and
padded with <code>padding</code>. If <code>padding</code> is not present, it defaults to
whitespace. When <code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is
returned</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#slice/3">slice(string, start, len)</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a substring starting at the offset <code>start</code>, and of
length <code>len</code></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#splitter/3">splitter(string, pattern, options \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Splits a string on demand</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#replace/4">replace(subject, pattern, replacement, options \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns a new binary created by replacing occurences of <code>pattern</code> in
<code>subject</code> with <code>replacement</code></p>
</div>
  
</div>

  </div>


          

          

        </section>
      

      
        <section id="types_details" class="types details-list">
          <h1 class="section-heading">Types</h1>
          <div class="types-list">
            <div class="type-detail">
  <pre><code class="elixir" id="t:t/0"><a href="#t:t/0">t</a> :: binary</code></pre>
  
</div>
<div class="type-detail">
  <pre><code class="elixir" id="t:codepoint/0"><a href="#t:codepoint/0">codepoint</a> :: <a href="#t:t/0">t</a></code></pre>
  
</div>
<div class="type-detail">
  <pre><code class="elixir" id="t:grapheme/0"><a href="#t:grapheme/0">grapheme</a> :: <a href="#t:t/0">t</a></code></pre>
  
</div>
<div class="type-detail">
  <pre><code class="elixir" id="t:pattern/0"><a href="#t:pattern/0">pattern</a> :: <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>] | :binary.cp</code></pre>
  
</div>

          </div>
        </section>
      

      
        <section id="functions_details" class="details-list">
          <h1 class="section-heading">Functions</h1>
          <div class="detail">
  <div class="detail-header" id="at/2">
    <a href="#at/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">at(string, position)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">at(<a href="#t:t/0">t</a>, integer) :: <a href="#t:grapheme/0">grapheme</a> | nil</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the grapheme in the <code>position</code> of the given utf8 <code>string</code>.
If <code>position</code> is greater than <code>string</code> length, then it returns <code>nil</code>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.at(&quot;elixir&quot;, 0)
&quot;e&quot;

iex&gt; String.at(&quot;elixir&quot;, 1)
&quot;l&quot;

iex&gt; String.at(&quot;elixir&quot;, 10)
nil

iex&gt; String.at(&quot;elixir&quot;, -1)
&quot;r&quot;

iex&gt; String.at(&quot;elixir&quot;, -10)
nil
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="capitalize/1">
    <a href="#capitalize/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">capitalize(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">capitalize(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Converts the first character in the given string to
uppercase and the remainder to lowercase.</p>

<p>This relies on the titlecase information provided
by the Unicode Standard. Note this function makes
no attempt to capitalize all words in the string
(usually known as titlecase).</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.capitalize(&quot;abcd&quot;)
&quot;Abcd&quot;

iex&gt; String.capitalize(&quot;ﬁn&quot;)
&quot;Fin&quot;

iex&gt; String.capitalize(&quot;olá&quot;)
&quot;Olá&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="chunk/2">
    <a href="#chunk/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">chunk(string, trait)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">chunk(<a href="#t:t/0">t</a>, :valid | :printable) :: [<a href="#t:t/0">t</a>]</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Splits the string into chunks of characters that share a common trait.</p>

<p>The trait can be one of two options:</p>

<ul>
<li><p><code>:valid</code>     - the string is split into chunks of valid and invalid character
sequences</p></li>
<li><p><code>:printable</code> - the string is split into chunks of printable and
non-printable character sequences</p></li>
</ul>

<p>Returns a list of binaries each of which contains only one kind of
characters.</p>

<p>If the given string is empty, an empty list is returned.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0&gt;&gt;, :valid)
[&quot;abc\0&quot;]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0ffff::utf8&gt;&gt;, :valid)
[&quot;abc\0&quot;, &lt;&lt;0x0ffff::utf8&gt;&gt;]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0ffff::utf8&gt;&gt;, :printable)
[&quot;abc&quot;, &lt;&lt;0, 0x0ffff::utf8&gt;&gt;]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="codepoints/1">
    <a href="#codepoints/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">codepoints(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">codepoints(<a href="#t:t/0">t</a>) :: [<a href="#t:codepoint/0">codepoint</a>]</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns all codepoints in the string.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.codepoints(&quot;olá&quot;)
[&quot;o&quot;, &quot;l&quot;, &quot;á&quot;]

iex&gt; String.codepoints(&quot;оптими зации&quot;)
[&quot;о&quot;, &quot;п&quot;, &quot;т&quot;, &quot;и&quot;, &quot;м&quot;, &quot;и&quot;, &quot; &quot;, &quot;з&quot;, &quot;а&quot;, &quot;ц&quot;, &quot;и&quot;, &quot;и&quot;]

iex&gt; String.codepoints(&quot;ἅἪῼ&quot;)
[&quot;ἅ&quot;, &quot;Ἢ&quot;, &quot;ῼ&quot;]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="contains?/2">
    <a href="#contains?/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">contains?(string, contents)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">contains?(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a>) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Checks if <code>string</code> contains any of the given <code>contents</code>.</p>

<p><code>contents</code> can be either a single string or a list of strings.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.contains? &quot;elixir of life&quot;, &quot;of&quot;
true

iex&gt; String.contains? &quot;elixir of life&quot;, [&quot;life&quot;, &quot;death&quot;]
true

iex&gt; String.contains? &quot;elixir of life&quot;, [&quot;death&quot;, &quot;mercury&quot;]
false
</code></pre>

<p>The argument can also be a precompiled pattern:</p>

<pre><code class="iex elixir">iex&gt; pattern = :binary.compile_pattern([&quot;life&quot;, &quot;death&quot;])
iex&gt; String.contains? &quot;elixir of life&quot;, pattern
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="downcase/1">
    <a href="#downcase/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">downcase(binary)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">downcase(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Converts all characters in the given string to lowercase.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.downcase(&quot;ABCD&quot;)
&quot;abcd&quot;

iex&gt; String.downcase(&quot;AB 123 XPTO&quot;)
&quot;ab 123 xpto&quot;

iex&gt; String.downcase(&quot;OLÁ&quot;)
&quot;olá&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="duplicate/2">
    <a href="#duplicate/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">duplicate(subject, n)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">duplicate(<a href="#t:t/0">t</a>, non_neg_integer) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a binary <code>subject</code> duplicated <code>n</code> times.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.duplicate(&quot;abc&quot;, 0)
&quot;&quot;

iex&gt; String.duplicate(&quot;abc&quot;, 1)
&quot;abc&quot;

iex&gt; String.duplicate(&quot;abc&quot;, 2)
&quot;abcabc&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="ends_with?/2">
    <a href="#ends_with?/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">ends_with?(string, suffixes)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">ends_with?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>string</code> ends with any of the suffixes given, otherwise
returns <code>false</code>. <code>suffixes</code> can be either a single suffix or a list of suffixes.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.ends_with? &quot;language&quot;, &quot;age&quot;
true

iex&gt; String.ends_with? &quot;language&quot;, [&quot;youth&quot;, &quot;age&quot;]
true

iex&gt; String.ends_with? &quot;language&quot;, [&quot;youth&quot;, &quot;elixir&quot;]
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="first/1">
    <a href="#first/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">first(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">first(<a href="#t:t/0">t</a>) :: <a href="#t:grapheme/0">grapheme</a> | nil</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the first grapheme from a utf8 string,
<code>nil</code> if the string is empty.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.first(&quot;elixir&quot;)
&quot;e&quot;

iex&gt; String.first(&quot;եոգլի&quot;)
&quot;ե&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="graphemes/1">
    <a href="#graphemes/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">graphemes(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">graphemes(<a href="#t:t/0">t</a>) :: [<a href="#t:grapheme/0">grapheme</a>]</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns Unicode graphemes in the string as per Extended Grapheme
Cluster algorithm outlined in the <a href="http://www.unicode.org/reports/tr29/">Unicode Standard Annex #29,
Unicode Text Segmentation</a>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.graphemes(&quot;Ńaïve&quot;)
[&quot;Ń&quot;, &quot;a&quot;, &quot;ï&quot;, &quot;v&quot;, &quot;e&quot;]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="jaro_distance/2">
    <a href="#jaro_distance/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">jaro_distance(str1, str2)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">jaro_distance(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: 0 .. 1</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a float value between 0 (equates to no similarity) and 1 (is an exact match)
representing <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro</a>
distance between <code>str1</code> and <code>str2</code>.</p>

<p>The Jaro distance metric is designed and best suited for short strings such as person names.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.jaro_distance(&quot;dwayne&quot;, &quot;duane&quot;)
0.8222222222222223
iex&gt; String.jaro_distance(&quot;even&quot;, &quot;odd&quot;)
0.0
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="last/1">
    <a href="#last/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">last(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">last(<a href="#t:t/0">t</a>) :: <a href="#t:grapheme/0">grapheme</a> | nil</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the last grapheme from a utf8 string,
<code>nil</code> if the string is empty.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.last(&quot;elixir&quot;)
&quot;r&quot;

iex&gt; String.last(&quot;եոգլի&quot;)
&quot;ի&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="length/1">
    <a href="#length/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">length(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">length(<a href="#t:t/0">t</a>) :: non_neg_integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the number of Unicode graphemes in a utf8 string.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.length(&quot;elixir&quot;)
6

iex&gt; String.length(&quot;եոգլի&quot;)
5
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="ljust/3">
    <a href="#ljust/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">ljust(subject, len, pad \\ 32)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">ljust(<a href="#t:t/0">t</a>, non_neg_integer, char) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a new string of length <code>len</code> with <code>subject</code> left justified and padded
with <code>padding</code>. If <code>padding</code> is not present, it defaults to whitespace. When
<code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is returned.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.ljust(&quot;abc&quot;, 5)
&quot;abc  &quot;

iex&gt; String.ljust(&quot;abc&quot;, 5, ?-)
&quot;abc--&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="lstrip/1">
    <a href="#lstrip/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">lstrip(binary)</span>
      
  </div>
  
  <section class="docstring">
    <p>Returns a string where all leading Unicode whitespaces
has been removed.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.lstrip(&quot;   abc  &quot;)
&quot;abc  &quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="lstrip/2">
    <a href="#lstrip/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">lstrip(string, char)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">lstrip(<a href="#t:t/0">t</a>, char) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a string where all leading <code>char</code>s have been removed.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.lstrip(&quot;_  abc  _&quot;, ?_)
&quot;  abc  _&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="match?/2">
    <a href="#match?/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">match?(string, regex)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">match?(<a href="#t:t/0">t</a>, Regex.t) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Checks if <code>string</code> matches the given regular expression.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.match?(&quot;foo&quot;, ~r/foo/)
true

iex&gt; String.match?(&quot;bar&quot;, ~r/foo/)
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="next_codepoint/1">
    <a href="#next_codepoint/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">next_codepoint(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">next_codepoint(<a href="#t:t/0">t</a>) :: {<a href="#t:codepoint/0">codepoint</a>, <a href="#t:t/0">t</a>} | nil</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the next codepoint in a String.</p>

<p>The result is a tuple with the codepoint and the
remainder of the string or <code>nil</code> in case
the string reached its end.</p>

<p>As with other functions in the String module, this
function does not check for the validity of the codepoint.
That said, if an invalid codepoint is found, it will
be returned by this function.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.next_codepoint(&quot;olá&quot;)
{&quot;o&quot;, &quot;lá&quot;}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="next_grapheme/1">
    <a href="#next_grapheme/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">next_grapheme(binary)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">next_grapheme(<a href="#t:t/0">t</a>) :: {<a href="#t:grapheme/0">grapheme</a>, <a href="#t:t/0">t</a>} | nil</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the next grapheme in a string.</p>

<p>The result is a tuple with the grapheme and the
remainder of the string or <code>nil</code> in case
the String reached its end.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.next_grapheme(&quot;olá&quot;)
{&quot;o&quot;, &quot;lá&quot;}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="next_grapheme_size/1">
    <a href="#next_grapheme_size/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">next_grapheme_size(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">next_grapheme_size(<a href="#t:t/0">t</a>) :: {pos_integer, <a href="#t:t/0">t</a>} | nil</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns the size of the next grapheme.</p>

<p>The result is a tuple with the next grapheme size and
the remainder of the string or <code>nil</code> in case the string
reached its end.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.next_grapheme_size(&quot;olá&quot;)
{1, &quot;lá&quot;}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="printable?/1">
    <a href="#printable?/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">printable?(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">printable?(<a href="#t:t/0">t</a>) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Checks if a string is printable considering it is encoded
as UTF-8. Returns <code>true</code> if so, <code>false</code> otherwise.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.printable?(&quot;abc&quot;)
true
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="replace/4">
    <a href="#replace/4" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">replace(subject, pattern, replacement, options \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">replace(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a> | Regex.t, <a href="#t:t/0">t</a>, Keyword.t) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a new binary created by replacing occurences of <code>pattern</code> in
<code>subject</code> with <code>replacement</code>.</p>

<p>By default, it replaces all occurences, except if the <code>global</code> option is
set to <code>false</code>.</p>

<p>A <code>pattern</code> may be a string or a regular expression.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;-&quot;)
&quot;a-b-c&quot;

iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;-&quot;, global: false)
&quot;a-b,c&quot;
</code></pre>

<p>The pattern can also be a regular expression. In those cases, one can give <code>\N</code> or
<code>\g{N}</code> in the <code>replacement</code> string to access a specific capture in the
regex:</p>

<pre><code class="iex elixir">iex&gt; String.replace(&quot;a,b,c&quot;, ~r/,(.)/, &quot;,\\1\\g{1}&quot;)
&quot;a,bb,cc&quot;
</code></pre>

<p>Notice we had to escape the escape character <code>\</code>. By giving <code>\0</code>,
one can inject the whole matched pattern in the replacement string.</p>

<p>When strings are used as a pattern, a developer can also use the
replaced part inside the <code>replacement</code> via the <code>:insert_replaced</code> option:</p>

<pre><code class="iex elixir">iex&gt; String.replace(&quot;a,b,c&quot;, &quot;b&quot;, &quot;[]&quot;, insert_replaced: 1)
&quot;a,[b],c&quot;

iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;[]&quot;, insert_replaced: 2)
&quot;a[],b[],c&quot;

iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;[]&quot;, insert_replaced: [1, 1])
&quot;a[,,]b[,,]c&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="reverse/1">
    <a href="#reverse/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">reverse(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">reverse(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Reverses the given string. Works on graphemes.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.reverse(&quot;abcd&quot;)
&quot;dcba&quot;

iex&gt; String.reverse(&quot;hello world&quot;)
&quot;dlrow olleh&quot;

iex&gt; String.reverse(&quot;hello ∂og&quot;)
&quot;go∂ olleh&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="rjust/3">
    <a href="#rjust/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">rjust(subject, len, pad \\ 32)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">rjust(<a href="#t:t/0">t</a>, non_neg_integer, char) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a new string of length <code>len</code> with <code>subject</code> right justified and
padded with <code>padding</code>. If <code>padding</code> is not present, it defaults to
whitespace. When <code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is
returned.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.rjust(&quot;abc&quot;, 5)
&quot;  abc&quot;

iex&gt; String.rjust(&quot;abc&quot;, 5, ?-)
&quot;--abc&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="rstrip/1">
    <a href="#rstrip/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">rstrip(binary)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">rstrip(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a string where all trailing Unicode whitespaces
has been removed.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.rstrip(&quot;   abc  &quot;)
&quot;   abc&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="rstrip/2">
    <a href="#rstrip/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">rstrip(string, char)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">rstrip(<a href="#t:t/0">t</a>, char) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a string where all trailing <code>char</code>s have been removed.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.rstrip(&quot;   abc _&quot;, ?_)
&quot;   abc &quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="slice/2">
    <a href="#slice/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">slice(string, range)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">slice(<a href="#t:t/0">t</a>, Range.t) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a substring from the offset given by the start of the
range to the offset given by the end of the range.</p>

<p>If the start of the range is not a valid offset for the given
string or if the range is in reverse order, returns <code>&quot;&quot;</code>.</p>

<p>If the start or end of the range is negative, the whole string
is traversed first in order to convert the negative indices into
positive ones.</p>

<p>Remember this function works with Unicode codepoints and considers
the slices to represent codepoints offsets. If you want to split
on raw bytes, check <a href="Kernel.html#binary_part/3"><code>Kernel.binary_part/3</code></a> instead.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.slice(&quot;elixir&quot;, 1..3)
&quot;lix&quot;

iex&gt; String.slice(&quot;elixir&quot;, 1..10)
&quot;lixir&quot;

iex&gt; String.slice(&quot;elixir&quot;, 10..3)
&quot;&quot;

iex&gt; String.slice(&quot;elixir&quot;, -4..-1)
&quot;ixir&quot;

iex&gt; String.slice(&quot;elixir&quot;, 2..-1)
&quot;ixir&quot;

iex&gt; String.slice(&quot;elixir&quot;, -4..6)
&quot;ixir&quot;

iex&gt; String.slice(&quot;elixir&quot;, -1..-4)
&quot;&quot;

iex&gt; String.slice(&quot;elixir&quot;, -10..-7)
&quot;&quot;

iex&gt; String.slice(&quot;a&quot;, 0..1500)
&quot;a&quot;

iex&gt; String.slice(&quot;a&quot;, 1..1500)
&quot;&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="slice/3">
    <a href="#slice/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">slice(string, start, len)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">slice(<a href="#t:t/0">t</a>, integer, integer) :: <a href="#t:grapheme/0">grapheme</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a substring starting at the offset <code>start</code>, and of
length <code>len</code>.</p>

<p>If the offset is greater than string length, then it returns <code>&quot;&quot;</code>.</p>

<p>Remember this function works with Unicode codepoints and considers
the slices to represent codepoint offsets. If you want to split
on raw bytes, check <a href="Kernel.html#binary_part/3"><code>Kernel.binary_part/3</code></a> instead.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.slice(&quot;elixir&quot;, 1, 3)
&quot;lix&quot;

iex&gt; String.slice(&quot;elixir&quot;, 1, 10)
&quot;lixir&quot;

iex&gt; String.slice(&quot;elixir&quot;, 10, 3)
&quot;&quot;

iex&gt; String.slice(&quot;elixir&quot;, -4, 4)
&quot;ixir&quot;

iex&gt; String.slice(&quot;elixir&quot;, -10, 3)
&quot;&quot;

iex&gt; String.slice(&quot;a&quot;, 0, 1500)
&quot;a&quot;

iex&gt; String.slice(&quot;a&quot;, 1, 1500)
&quot;&quot;

iex&gt; String.slice(&quot;a&quot;, 2, 1500)
&quot;&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="split/1">
    <a href="#split/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">split(binary)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">split(<a href="#t:t/0">t</a>) :: [<a href="#t:t/0">t</a>]</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Divides a string into substrings at each Unicode whitespace
occurrence with leading and trailing whitespace ignored.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.split(&quot;foo bar&quot;)
[&quot;foo&quot;, &quot;bar&quot;]

iex&gt; String.split(&quot;foo&quot; &lt;&gt; &lt;&lt;194, 133&gt;&gt; &lt;&gt; &quot;bar&quot;)
[&quot;foo&quot;, &quot;bar&quot;]

iex&gt; String.split(&quot; foo bar &quot;)
[&quot;foo&quot;, &quot;bar&quot;]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="split/3">
    <a href="#split/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">split(string, pattern, options \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">split(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a> | Regex.t, Keyword.t) :: [<a href="#t:t/0">t</a>]</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Divides a string into substrings based on a pattern.</p>

<p>Returns a list of these substrings. The pattern can
be a string, a list of strings or a regular expression.</p>

<p>The string is split into as many parts as possible by
default, but can be controlled via the <code>parts: num</code> option.
If you pass <code>parts: :infinity</code>, it will return all possible parts
(being this one the default behaviour).</p>

<p>Empty strings are only removed from the result if the
<code>trim</code> option is set to <code>true</code> (default is <code>false</code>).</p>

<h2>Examples</h2>

<p>Splitting with a string pattern:</p>

<pre><code class="iex elixir">iex&gt; String.split(&quot;a,b,c&quot;, &quot;,&quot;)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

iex&gt; String.split(&quot;a,b,c&quot;, &quot;,&quot;, parts: 2)
[&quot;a&quot;, &quot;b,c&quot;]

iex&gt; String.split(&quot; a b c &quot;, &quot; &quot;, trim: true)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>

<p>A list of patterns:</p>

<pre><code class="iex elixir">iex&gt; String.split(&quot;1,2 3,4&quot;, [&quot; &quot;, &quot;,&quot;])
[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
</code></pre>

<p>A regular expression:</p>

<pre><code class="iex elixir">iex&gt; String.split(&quot;a,b,c&quot;, ~r{,})
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

iex&gt; String.split(&quot;a,b,c&quot;, ~r{,}, parts: 2)
[&quot;a&quot;, &quot;b,c&quot;]

iex&gt; String.split(&quot; a b c &quot;, ~r{\s}, trim: true)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>

<p>Splitting on empty patterns returns codepoints:</p>

<pre><code class="iex elixir">iex&gt; String.split(&quot;abc&quot;, ~r{})
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]

iex&gt; String.split(&quot;abc&quot;, &quot;&quot;)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]

iex&gt; String.split(&quot;abc&quot;, &quot;&quot;, trim: true)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

iex&gt; String.split(&quot;abc&quot;, &quot;&quot;, parts: 2)
[&quot;a&quot;, &quot;bc&quot;]
</code></pre>

<p>A precompiled pattern can also be given:</p>

<pre><code class="iex elixir">iex&gt; pattern = :binary.compile_pattern([&quot; &quot;, &quot;,&quot;])
iex&gt; String.split(&quot;1,2 3,4&quot;, pattern)
[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="split_at/2">
    <a href="#split_at/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">split_at(string, position)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">split_at(<a href="#t:t/0">t</a>, integer) :: {<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>}</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Splits a string into two at the specified offset. When the offset given is
negative, location is counted from the end of the string.</p>

<p>The offset is capped to the length of the string. Returns a tuple with
two elements.</p>

<p>Note: keep in mind this function splits on graphemes and for such it
has to linearly traverse the string. If you want to split a string or
a binary based on the number of bytes, use <a href="Kernel.html#binary_part/3"><code>Kernel.binary_part/3</code></a>
instead.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.split_at &quot;sweetelixir&quot;, 5
{&quot;sweet&quot;, &quot;elixir&quot;}

iex&gt; String.split_at &quot;sweetelixir&quot;, -6
{&quot;sweet&quot;, &quot;elixir&quot;}

iex&gt; String.split_at &quot;abc&quot;, 0
{&quot;&quot;, &quot;abc&quot;}

iex&gt; String.split_at &quot;abc&quot;, 1000
{&quot;abc&quot;, &quot;&quot;}

iex&gt; String.split_at &quot;abc&quot;, -1000
{&quot;&quot;, &quot;abc&quot;}
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="splitter/3">
    <a href="#splitter/3" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">splitter(string, pattern, options \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">splitter(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a>, Keyword.t) :: Enumerable.t</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Splits a string on demand.</p>

<p>Returns an enumerable that splits the string on
demand, instead of splitting all data upfront.</p>

<p>Note splitter does not support regular expressions
(as it is often more efficient to have the regular
expressions traverse the string at once than in
multiple passes).</p>

<h2>Options</h2>

<ul>
<li>:trim - when <code>true</code>, does not emit empty patterns</li>
</ul>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="starts_with?/2">
    <a href="#starts_with?/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">starts_with?(string, prefix)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">starts_with?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns <code>true</code> if <code>string</code> starts with any of the prefixes given, otherwise
returns <code>false</code>. <code>prefixes</code> can be either a single prefix or a list of prefixes.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.starts_with? &quot;elixir&quot;, &quot;eli&quot;
true

iex&gt; String.starts_with? &quot;elixir&quot;, [&quot;erlang&quot;, &quot;elixir&quot;]
true

iex&gt; String.starts_with? &quot;elixir&quot;, [&quot;erlang&quot;, &quot;ruby&quot;]
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="strip/1">
    <a href="#strip/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">strip(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">strip(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a string where all leading and trailing Unicode whitespaces
has been removed.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.strip(&quot;   abc  &quot;)
&quot;abc&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="strip/2">
    <a href="#strip/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">strip(string, char)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">strip(<a href="#t:t/0">t</a>, char) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a string where all leading and trailing <code>char</code>s have been
removed.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.strip(&quot;a  abc  a&quot;, ?a)
&quot;  abc  &quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_atom/1">
    <a href="#to_atom/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_atom(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">to_atom(<a href="String.html#t:t/0">String.t</a>) :: atom</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Converts a string to an atom.</p>

<p>Currently Elixir does not support the conversion of strings
that contain Unicode codepoints greater than 0xFF.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.to_atom(&quot;my_atom&quot;)
:my_atom
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_char_list/1">
    <a href="#to_char_list/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_char_list(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">to_char_list(<a href="#t:t/0">t</a>) :: char_list</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Converts a string into a char list.</p>

<p>Specifically, this functions takes a UTF-8 encoded binary and returns a list of its integer
codepoints. It is similar to <a href="#codepoints/1"><code>codepoints/1</code></a> except that the latter returns a list of codepoints as
strings.</p>

<p>In case you need to work with bytes, take a look at the
<a href="http://www.erlang.org/doc/man/binary.html"><code>:binary</code> module</a>.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.to_char_list(&quot;æß&quot;)
&#39;æß&#39;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_existing_atom/1">
    <a href="#to_existing_atom/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_existing_atom(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">to_existing_atom(<a href="String.html#t:t/0">String.t</a>) :: atom</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Converts a string to an existing atom.</p>

<p>Currently Elixir does not support the conversion of strings
that contain Unicode codepoints greater than 0xFF.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; _ = :my_atom
iex&gt; String.to_existing_atom(&quot;my_atom&quot;)
:my_atom

iex&gt; String.to_existing_atom(&quot;this_atom_will_never_exist&quot;)
** (ArgumentError) argument error
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_float/1">
    <a href="#to_float/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_float(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">to_float(<a href="String.html#t:t/0">String.t</a>) :: float</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns a float whose text representation is <code>string</code>.</p>

<p><code>string</code> must be the string representation of a float.
If a string representation of an integer wants to be used,
then <code>Float.parse/1</code> should be used instead,
otherwise an argument error will be raised.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.to_float(&quot;2.2017764e+0&quot;)
2.2017764

iex&gt; String.to_float(&quot;3.0&quot;)
3.0
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_integer/1">
    <a href="#to_integer/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_integer(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">to_integer(<a href="String.html#t:t/0">String.t</a>) :: integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns an integer whose text representation is <code>string</code>.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.to_integer(&quot;123&quot;)
123
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="to_integer/2">
    <a href="#to_integer/2" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">to_integer(string, base)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">to_integer(<a href="String.html#t:t/0">String.t</a>, 2 .. 36) :: integer</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Returns an integer whose text representation is <code>string</code> in base <code>base</code>.</p>

<p>Inlined by the compiler.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.to_integer(&quot;3FF&quot;, 16)
1023
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="upcase/1">
    <a href="#upcase/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">upcase(binary)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">upcase(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Converts all characters in the given string to uppercase.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.upcase(&quot;abcd&quot;)
&quot;ABCD&quot;

iex&gt; String.upcase(&quot;ab 123 xpto&quot;)
&quot;AB 123 XPTO&quot;

iex&gt; String.upcase(&quot;olá&quot;)
&quot;OLÁ&quot;
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="valid?/1">
    <a href="#valid?/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">valid?(string)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">valid?(<a href="#t:t/0">t</a>) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Checks whether <code>str</code> contains only valid characters.</p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.valid?(&quot;a&quot;)
true

iex&gt; String.valid?(&quot;ø&quot;)
true

iex&gt; String.valid?(&lt;&lt;0xffff :: 16&gt;&gt;)
false

iex&gt; String.valid?(&quot;asd&quot; &lt;&gt; &lt;&lt;0xffff :: 16&gt;&gt;)
false
</code></pre>

  </section>
</div>
<div class="detail">
  <div class="detail-header" id="valid_character?/1">
    <a href="#valid_character?/1" class="detail-link" title="Link to this function">
      <i class="fa fa-link"></i>
    </a>
    <span class="signature">valid_character?(codepoint)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">valid_character?(<a href="#t:t/0">t</a>) :: boolean</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Checks whether <code>string</code> is a valid character.</p>

<p>All characters are codepoints, but some codepoints
are not valid characters. They may be reserved, private,
or other.</p>

<p>More info at: <a href="https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Non-characters">Non-characters – Wikipedia</a></p>

<h2>Examples</h2>

<pre><code class="iex elixir">iex&gt; String.valid_character?(&quot;a&quot;)
true

iex&gt; String.valid_character?(&quot;ø&quot;)
true

iex&gt; String.valid_character?(&quot;\uFFFF&quot;)
false
</code></pre>

  </section>
</div>

        </section>
      

      

      
        <footer class="footer">
      <p>
        Designed by
        <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>
        and the
        <a href="https://github.com/elixir-lang/ex_doc/graphs/contributors" target="_blank">ExDoc team</a>.
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.9.1-dev).
      </p>
    </footer>
  </div>
</section>
</div>
    <script src="dist/app.js"></script>
  </body>
</html>

