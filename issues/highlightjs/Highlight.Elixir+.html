<!DOCTYPE html>
<html>
  <head>
    <title>Highlight.Elixir</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="css/elixir.css" type="text/css" media="screen" charset="utf-8" />
    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/highlight.pack.js"></script>
    <script type="text/javascript" charset="utf-8">
      hljs.initHighlightingOnLoad();
      // languages supported: 'bash', 'coffeescript', 'css', 'diff', 'elixir', 'erlang', 'erlang-repl', 'http', 'javascript', 'json', 'markdown', 'sql', 'xml'
      
      /* languages supported and their aliases
        bash, sh, zsh,
        coffeescript, coffee, cson, iced,
        css,
        diff, patch,
        elixir, iex,
        erlang, erl,
        erlang-repl,
        http,
        javascript, js,
        json,
        markdown, md, mkdown, mkd,
        sql,
        xml, html, xhtml, rss, atom, xsl, plist,
      */
      hljs.configure({languages: []}); //disable autodetect
    </script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <section id="content">
      <div class="breadcrumbs">Highlight v0.0.1 &rarr; <a href="overview.html">Overview</a> &rarr; <a href="Highlight.html">Highlight</a> &rarr; <a href="Highlight.Elixir.html">Elixir</a></div>
      <h1>
        Highlight.Elixir
        
      </h1>

      <ul class="summary_links">
        
          <li><a href="#summary">Summary</a></li>
        
        
        
          <li><a href="#functions_details">Functions</a></li>
        
        
        
      </ul>

      
        <section id="moduledoc" class="docstring">
          <p>Load all the test files for different highlighting, validation and language feature showcases.</p>

        </section>
      

      

      
        <h2 id="summary">Summary<span class="detail_header_links"><a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></span></h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#learnxinyminutes/0">learnxinyminutes()</a></td>
  
    <td class="summary_synopsis"><p><a href="http://learnxinyminutes.com">Learn X in Y Minutes</a>. Take a whirlwind tour of your next favorite language</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#pygments/0">pygments()</a></td>
  
    <td class="summary_synopsis"><p><a href="http://pygments.org">Pygments</a>. Python sintax highlighter</p>
</td>
  
</tr>

        </table>
      

      

      
        <section id="functions_details" class="details_list">
          <h2>Functions</h2>
          <section class="detail">
  <div class="detail_header" id="learnxinyminutes/0">
    <span class="signature"><strong>learnxinyminutes()</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#learnxinyminutes/0" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p><a href="http://learnxinyminutes.com">Learn X in Y Minutes</a>. Take a whirlwind tour of your next favorite language.</p>
<p>Source: <a href="http://learnxinyminutes.com/docs/files/learnelixir.ex">http://learnxinyminutes.com/docs/files/learnelixir.ex</a></p>
<pre><code class="elixir"># Single line comments start with a number symbol.

# There&#39;s no multi-line comment,
# but you can stack multiple comments.

# To use the elixir shell use the `iex` command.
# Compile your modules with the `elixirc` command.

# Both should be in your path if you installed elixir correctly.

## ---------------------------
## -- Basic types
## ---------------------------

# There are numbers
3    # integer
0x1F # integer
3.0  # float

# Atoms, that are literals, a constant with name. They start with `:`.
:hello # atom

# Tuples that are stored contiguously in memory.
{1,2,3} # tuple

# We can access a tuple element with the `elem` function:
elem({1, 2, 3}, 0) #=&gt; 1

# Lists that are implemented as linked lists.
[1,2,3] # list

# We can access the head and tail of a list as follows:
[head | tail] = [1,2,3]
head #=&gt; 1
tail #=&gt; [2,3]

# In elixir, just like in Erlang, the `=` denotes pattern matching and
# not an assignment.
#
# This means that the left-hand side (pattern) is matched against a
# right-hand side.
#
# This is how the above example of accessing the head and tail of a list works.

# A pattern match will error when the sides don&#39;t match, in this example
# the tuples have different sizes.
# {a, b, c} = {1, 2} #=&gt; ** (MatchError) no match of right hand side value: {1,2}

# There are also binaries
&lt;&lt;1,2,3&gt;&gt; # binary

# Strings and char lists
&quot;hello&quot; # string
&#39;hello&#39; # char list

# Multi-line strings
&quot;&quot;&quot;
I&#39;m a multi-line
string.
&quot;&quot;&quot;
#=&gt; &quot;I&#39;m a multi-line\nstring.\n&quot;

# Strings are all encoded in UTF-8:
&quot;héllò&quot; #=&gt; &quot;héllò&quot;

# Strings are really just binaries, and char lists are just lists.
&lt;&lt;?a, ?b, ?c&gt;&gt; #=&gt; &quot;abc&quot;
[?a, ?b, ?c]   #=&gt; &#39;abc&#39;

# `?a` in elixir returns the ASCII integer for the letter `a`
?a #=&gt; 97

# To concatenate lists use `++`, for binaries use `&lt;&gt;`
[1,2,3] ++ [4,5]     #=&gt; [1,2,3,4,5]
&#39;hello &#39; ++ &#39;world&#39;  #=&gt; &#39;hello world&#39;

&lt;&lt;1,2,3&gt;&gt; &lt;&gt; &lt;&lt;4,5&gt;&gt; #=&gt; &lt;&lt;1,2,3,4,5&gt;&gt;
&quot;hello &quot; &lt;&gt; &quot;world&quot;  #=&gt; &quot;hello world&quot;

# Ranges are represented as `start..end` (both inclusive)
1..10 #=&gt; 1..10
lower..upper = 1..10 # Can use pattern matching on ranges as well
[lower, upper] #=&gt; [1, 10]

## ---------------------------
## -- Operators
## ---------------------------

# Some math
1 + 1  #=&gt; 2
10 - 5 #=&gt; 5
5 * 2  #=&gt; 10
10 / 2 #=&gt; 5.0

# In elixir the operator `/` always returns a float.

# To do integer division use `div`
div(10, 2) #=&gt; 5

# To get the division remainder use `rem`
rem(10, 3) #=&gt; 1

# There are also boolean operators: `or`, `and` and `not`.
# These operators expect a boolean as their first argument.
true and true #=&gt; true
false or true #=&gt; true
# 1 and true    #=&gt; ** (ArgumentError) argument error

# Elixir also provides `||`, `&amp;&amp;` and `!` which accept arguments of any type.
# All values except `false` and `nil` will evaluate to true.
1 || true  #=&gt; 1
false &amp;&amp; 1 #=&gt; false
nil &amp;&amp; 20  #=&gt; nil
!true #=&gt; false

# For comparisons we have: `==`, `!=`, `===`, `!==`, `&lt;=`, `&gt;=`, `&lt;` and `&gt;`
1 == 1 #=&gt; true
1 != 1 #=&gt; false
1 &lt; 2  #=&gt; true

# `===` and `!==` are more strict when comparing integers and floats:
1 == 1.0  #=&gt; true
1 === 1.0 #=&gt; false

# We can also compare two different data types:
1 &lt; :hello #=&gt; true

# The overall sorting order is defined below:
# number &lt; atom &lt; reference &lt; functions &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string

# To quote Joe Armstrong on this: &quot;The actual order is not important,
# but that a total ordering is well defined is important.&quot;

## ---------------------------
## -- Control Flow
## ---------------------------

# `if` expression
if false do
  &quot;This will never be seen&quot;
else
  &quot;This will&quot;
end

# There&#39;s also `unless`
unless true do
  &quot;This will never be seen&quot;
else
  &quot;This will&quot;
end

# Remember pattern matching? Many control-flow structures in elixir rely on it.

# `case` allows us to compare a value against many patterns:
case {:one, :two} do
  {:four, :five} -&gt;
    &quot;This won&#39;t match&quot;
  {:one, x} -&gt;
    &quot;This will match and bind `x` to `:two`&quot;
  _ -&gt;
    &quot;This will match any value&quot;
end

# It&#39;s common to bind the value to `_` if we don&#39;t need it.
# For example, if only the head of a list matters to us:
[head | _] = [1,2,3]
head #=&gt; 1

# For better readability we can do the following:
[head | _tail] = [:a, :b, :c]
head #=&gt; :a

# `cond` lets us check for many conditions at the same time.
# Use `cond` instead of nesting many `if` expressions.
cond do
  1 + 1 == 3 -&gt;
    &quot;I will never be seen&quot;
  2 * 5 == 12 -&gt;
    &quot;Me neither&quot;
  1 + 2 == 3 -&gt;
    &quot;But I will&quot;
end

# It is common to see the last condition equal to `true`, which will always match.
cond do
  1 + 1 == 3 -&gt;
    &quot;I will never be seen&quot;
  2 * 5 == 12 -&gt;
    &quot;Me neither&quot;
  true -&gt;
    &quot;But I will (this is essentially an else)&quot;
end

# `try/catch` is used to catch values that are thrown, it also supports an
# `after` clause that is invoked whether or not a value is caught.
try do
  throw(:hello)
catch
  message -&gt; &quot;Got #{message}.&quot;
after
  IO.puts(&quot;I&#39;m the after clause.&quot;)
end
#=&gt; I&#39;m the after clause
# &quot;Got :hello&quot;

## ---------------------------
## -- Modules and Functions
## ---------------------------

# Anonymous functions (notice the dot)
square = fn(x) -&gt; x * x end
square.(5) #=&gt; 25

# They also accept many clauses and guards.
# Guards let you fine tune pattern matching,
# they are indicated by the `when` keyword:
f = fn
  x, y when x &gt; 0 -&gt; x + y
  x, y -&gt; x * y
end

f.(1, 3)  #=&gt; 4
f.(-1, 3) #=&gt; -3

# Elixir also provides many built-in functions.
# These are available in the current scope.
is_number(10)    #=&gt; true
is_list(&quot;hello&quot;) #=&gt; false
elem({1,2,3}, 0) #=&gt; 1

# You can group several functions into a module. Inside a module use `def`
# to define your functions.
defmodule Math do
  def sum(a, b) do
    a + b
  end

  def square(x) do
    x * x
  end
end

Math.sum(1, 2)  #=&gt; 3
Math.square(3) #=&gt; 9

# To compile our simple Math module save it as `math.ex` and use `elixirc`
# in your terminal: elixirc math.ex

# Inside a module we can define functions with `def` and private functions with `defp`.
# A function defined with `def` is available to be invoked from other modules,
# a private function can only be invoked locally.
defmodule PrivateMath do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

PrivateMath.sum(1, 2)    #=&gt; 3
# PrivateMath.do_sum(1, 2) #=&gt; ** (UndefinedFunctionError)

# Function declarations also support guards and multiple clauses:
defmodule Geometry do
  def area({:rectangle, w, h}) do
    w * h
  end

  def area({:circle, r}) when is_number(r) do
    3.14 * r * r
  end
end

Geometry.area({:rectangle, 2, 3}) #=&gt; 6
Geometry.area({:circle, 3})       #=&gt; 28.25999999999999801048
# Geometry.area({:circle, &quot;not_a_number&quot;})
#=&gt; ** (FunctionClauseError) no function clause matching in Geometry.area/1

# Due to immutability, recursion is a big part of elixir
defmodule Recursion do
  def sum_list([head | tail], acc) do
    sum_list(tail, acc + head)
  end

  def sum_list([], acc) do
    acc
  end
end

Recursion.sum_list([1,2,3], 0) #=&gt; 6

# Elixir modules support attributes, there are built-in attributes and you
# may also add custom ones.
defmodule MyMod do
  @moduledoc &quot;&quot;&quot;
  This is a built-in attribute on a example module.
  &quot;&quot;&quot;

  @my_data 100 # This is a custom attribute.
  IO.inspect(@my_data) #=&gt; 100
end

## ---------------------------
## -- Structs and Exceptions
## ---------------------------

# Structs are extensions on top of maps that bring default values,
# compile-time guarantees and polymorphism into Elixir.
defmodule Person do
  defstruct name: nil, age: 0, height: 0
end

joe_info = %Person{ name: &quot;Joe&quot;, age: 30, height: 180 }
#=&gt; %Person{age: 30, height: 180, name: &quot;Joe&quot;}

# Access the value of name
joe_info.name #=&gt; &quot;Joe&quot;

# Update the value of age
older_joe_info = %{ joe_info | age: 31 }
#=&gt; %Person{age: 31, height: 180, name: &quot;Joe&quot;}

# The `try` block with the `rescue` keyword is used to handle exceptions
try do
  raise &quot;some error&quot;
rescue
  RuntimeError -&gt; &quot;rescued a runtime error&quot;
  _error -&gt; &quot;this will rescue any error&quot;
end

# All exceptions have a message
try do
  raise &quot;some error&quot;
rescue
  x in [RuntimeError] -&gt;
    x.message
end

## ---------------------------
## -- Concurrency
## ---------------------------

# Elixir relies on the actor model for concurrency. All we need to write
# concurrent programs in elixir are three primitives: spawning processes,
# sending messages and receiving messages.

# To start a new process we use the `spawn` function, which takes a function
# as argument.
f = fn -&gt; 2 * 2 end #=&gt; #Function&lt;erl_eval.20.80484245&gt;
spawn(f) #=&gt; #PID&lt;0.40.0&gt;

# `spawn` returns a pid (process identifier), you can use this pid to send
# messages to the process. To do message passing we use the `send` operator.
# For all of this to be useful we need to be able to receive messages. This is
# achieved with the `receive` mechanism:
defmodule Geometry do
  def area_loop do
    receive do
      {:rectangle, w, h} -&gt;
        IO.puts(&quot;Area = #{w * h}&quot;)
        area_loop()
      {:circle, r} -&gt;
        IO.puts(&quot;Area = #{3.14 * r * r}&quot;)
        area_loop()
    end
  end
end

# Compile the module and create a process that evaluates `area_loop` in the shell
pid = spawn(fn -&gt; Geometry.area_loop() end) #=&gt; #PID&lt;0.40.0&gt;

# Send a message to `pid` that will match a pattern in the receive statement
send pid, {:rectangle, 2, 3}
#=&gt; Area = 6
#   {:rectangle,2,3}

send pid, {:circle, 2}
#=&gt; Area = 12.56000000000000049738
#   {:circle,2}

# The shell is also a process, you can use `self` to get the current pid
self() #=&gt; #PID&lt;0.27.0&gt;</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="pygments/0">
    <span class="signature"><strong>pygments()</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#pygments/0" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p><a href="http://pygments.org">Pygments</a>. Python sintax highlighter</p>
<p>Generic syntax highlighter suitable for use in code hosting, forums, wikis or other applications that need to prettify source code</p>
<p>Source: <a href="https://bitbucket.org/birkenfeld/pygments-main/src/tip/tests/examplefiles/example_elixir.ex">https://bitbucket.org/birkenfeld/pygments-main/src/tip/tests/examplefiles/example_elixir.ex</a></p>
<pre><code class="elixir"># Numbers
0b0101011
1234 ; 0x1A ; 0xbeef ; 0763 ; 0o123
3.14 ; 5.0e21 ; 0.5e-12
100_000_000

# these are not valid numbers
0b012 ; 0xboar ; 0o888
0B01 ; 0XAF ; 0O123

# Characters
?a ; ?1 ; ?\n ; ?\s ; ?\c ; ? ; ?,
?\x{12} ; ?\x{abcd}
?\x34 ; ?\xF

# these show that only the first digit is part of the character
?\123 ; ?\12 ; ?\7

# Atoms
:this ; :that
:&#39;complex atom&#39;
:&quot;with&#39; \&quot;\&quot; &#39;quotes&quot;
:&quot; multi
 line &#39; \s \123 \xff
atom&quot;
:... ; :&lt;&lt;&gt;&gt; ; :%{} ; :% ; :{}
:++; :--; :*; :~~~; :::
:% ; :. ; :&lt;-

# Strings
&quot;Hello world&quot;
&quot;Interspersed \x{ff} codes \7 \8 \65 \016 and \t\s\\s\z\+ \\ escapes&quot;
&quot;Quotes &#39; inside \&quot; \123 the \&quot;\&quot; \xF \\xF string \\\&quot; end&quot;
&quot;Multiline
   string&quot;

# Char lists
&#39;this is a list&#39;
&#39;escapes \&#39; \t \\\&#39;&#39;
&#39;Multiline
    char
  list
&#39;

# Binaries
&lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;&quot;hello&quot;::binary, c :: utf8, x::[4, unit(2)]&gt;&gt; = &quot;hello™1&quot;

# Sigils
~r/this + i\s &quot;a&quot; regex/
&lt;&lt;1, 2, 3&gt;&gt;#comment
~w(hello #{ [&quot;has&quot; &lt;&gt; &quot;123&quot;, &#39;\c\d&#39;, &quot;\123 interpol&quot; | []] } world)s
&lt;&lt;1, 2, 3&gt;&gt;#comment
~W(hello #{no &quot;123&quot; \c\d \123 interpol} world)s
&lt;&lt;1, 2, 3&gt;&gt;#comment

&quot;this a string #and this shouldn not be commented&quot;
&quot;this a string #{and this shouldn not be commented} ss&quot;

~s{Escapes terminators \{ and \}, but no {balancing} # outside of sigil here }

~S&quot;No escapes \s\t\n and no #{interpolation}&quot;

:&quot;atoms work #{&quot;to&quot; &lt;&gt; &quot;o&quot;}&quot;

# Operators
x = 1 + 2.0 * 3
y = true and false; z = false or true
... = 144
... == !x &amp;&amp; y || z
&quot;hello&quot; |&gt; String.upcase |&gt; String.downcase()
{^z, a} = {true, x}

# Free operators (added in 1.0.0)
p  ~&gt;&gt; f  = bind(p, f)
p1 ~&gt;  p2 = pair_right(p1, p2)
p1 &lt;~  p2 = pair_left(p1, p2)
p1 &lt;~&gt; p2 = pair_both(p1, p2)
p  |~&gt; f  = map(p, f)
p1 &lt;|&gt; p2 = either(p1, p2)

# Lists, tuples, maps, keywords
[1, :a, &#39;hello&#39;] ++ [2, 3]
[:head | [?t, ?a, ?i, ?l]]

{:one, 2.0, &quot;three&quot;}

[...: &quot;this&quot;, &lt;&lt;&gt;&gt;: &quot;is&quot;, %{}: &quot;a keyword&quot;, %: &quot;list&quot;, {}: &quot;too&quot;]
[&quot;this is an atom too&quot;: 1, &quot;so is this&quot;: 2]
[option: &quot;value&quot;, key: :word]
[++: &quot;operator&quot;, ~~~: :&amp;&amp;&amp;]

map = %{shortcut: &quot;syntax&quot;}
%{map | &quot;update&quot; =&gt; &quot;me&quot;}
%{ 12 =&gt; 13, :weird =&gt; [&#39;thing&#39;] }

# Comprehensions
for x &lt;- 1..10, x &lt; 5, do: {x, x}
pixels = &quot;12345678&quot;
for &lt;&lt; &lt;&lt;r::4, g::4, b::4, a::size(4)&gt;&gt; &lt;- pixels &gt;&gt; do
  [r, {g, %{&quot;b&quot; =&gt; a}}]
end

# String interpolation
&quot;String #{inspect &quot;interpolation&quot;} is quite #{1+4+7} difficult&quot;

# Identifiers
abc_123 = 1
_018OP = 2
A__0 == 3

# Modules
defmodule Long.Module.Name do
  @moduledoc &quot;Simple module docstring&quot;

  @doc &quot;&quot;&quot;
  Multiline docstring
  &quot;with quotes&quot;
  and #{ inspect %{&quot;interpolation&quot; =&gt; &quot;in&quot; &lt;&gt; &quot;action&quot;} }
  now with #{ {:a, &#39;tuple&#39;} }
  and #{ inspect {
      :tuple,
      %{ with: &quot;nested #{ inspect %{ :interpolation =&gt; %{} } }&quot; }
  } }
  &quot;&quot;&quot;
  defstruct [:a, :name, :height]

  @doc false
  def __before_compile__(_) do
    :ok
  end
end

# Structs
defmodule Second.Module do
  s = %Long.Module.Name{name: &quot;Silly&quot;}
  %Long.Module.Name{s | height: {192, :cm}}
  &quot;.. #{%Long.Module.Name{s | height: {192, :cm}}} ..&quot;
end

# Types, pseudo-vars, attributes
defmodule M do
  @custom_attr :some_constant

  @before_compile Long.Module.Name

  @typedoc &quot;This is a type&quot;
  @type typ :: integer

  @typedoc &quot;&quot;&quot;
  Another type
  &quot;&quot;&quot;
  @opaque typtyp :: 1..10

  @spec func(typ, typtyp) :: :ok | :fail
  def func(a, b) do
    a || b || :ok || :fail
    Path.expand(&quot;..&quot;, __DIR__)
    IO.inspect __ENV__
    __NOTAPSEUDOVAR__ = 11
    __MODULE__.func(b, a)
  end

  defmacro m() do
    __CALLER__
  end
end

# Functions
anon = fn x, y, z -&gt;
  fn(a, b, c) -&gt;
    &amp;(x + y - z * a / &amp;1 + b + div(&amp;2, c))
  end
end

&amp;Set.put(&amp;1, &amp;2) ; &amp; Set.put(&amp;1, &amp;2) ; &amp;( Set.put(&amp;1, &amp;1) )

# Function calls
anon.(1, 2, 3); self; hd([1,2,3])
Kernel.spawn(fn -&gt; :ok end)
IO.ANSI.black

# Control flow
if :this do
  :that
else
  :otherwise
end

pid = self
receive do
  {:EXIT, _} -&gt; :done
  {^pid, :_} -&gt; nil
  after 100 -&gt; :no_luck
end

case __ENV__.line do
  x when is_integer(x) -&gt; x
  x when x in 1..12 -&gt; -x
end

cond do
  false -&gt; &quot;too bad&quot;
  4 &gt; 5 -&gt; &quot;oops&quot;
  true -&gt; nil
end

# Lexical scope modifiers
alias Long.Module.Name, as: N0men123_and4
use Bitwise

4 &amp;&amp;&amp; 5
2 &lt;&lt;&lt; 3

# Protocols
defprotocol Useless do
  def func1(this)
  def func2(that)
end

defimpl Useless, for: Atom do
end

# Exceptions
defmodule NotAnError do
  defexception [:message]
end

raise NotAnError, message: &quot;This is not an error&quot;</code></pre>

  </section>
  
</section>

        </section>
      

      

      
    </section>
  </body>
</html>
